{"/home/travis/build/npmtest/node-npmtest-xstream/test.js":"/* istanbul instrument in package npmtest_xstream */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-xstream/lib.npmtest_xstream.js":"/* istanbul instrument in package npmtest_xstream */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_xstream = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_xstream = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-xstream/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-xstream && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_xstream */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_xstream\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_xstream.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_xstream.rollup.js'] =\n            local.assetsDict['/assets.npmtest_xstream.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_xstream.__dirname + '/lib.npmtest_xstream.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/index.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar symbol_observable_1 = require(\"symbol-observable\");\nvar NO = {};\nexports.NO = NO;\nfunction noop() { }\nfunction cp(a) {\n    var l = a.length;\n    var b = Array(l);\n    for (var i = 0; i < l; ++i)\n        b[i] = a[i];\n    return b;\n}\nfunction and(f1, f2) {\n    return function andFn(t) {\n        return f1(t) && f2(t);\n    };\n}\nfunction _try(c, t, u) {\n    try {\n        return c.f(t);\n    }\n    catch (e) {\n        u._e(e);\n        return NO;\n    }\n}\nvar NO_IL = {\n    _n: noop,\n    _e: noop,\n    _c: noop,\n};\nexports.NO_IL = NO_IL;\n// mutates the input\nfunction internalizeProducer(producer) {\n    producer._start = function _start(il) {\n        il.next = il._n;\n        il.error = il._e;\n        il.complete = il._c;\n        this.start(il);\n    };\n    producer._stop = producer.stop;\n}\nvar StreamSub = (function () {\n    function StreamSub(_stream, _listener) {\n        this._stream = _stream;\n        this._listener = _listener;\n    }\n    StreamSub.prototype.unsubscribe = function () {\n        this._stream.removeListener(this._listener);\n    };\n    return StreamSub;\n}());\nvar Observer = (function () {\n    function Observer(_listener) {\n        this._listener = _listener;\n    }\n    Observer.prototype.next = function (value) {\n        this._listener._n(value);\n    };\n    Observer.prototype.error = function (err) {\n        this._listener._e(err);\n    };\n    Observer.prototype.complete = function () {\n        this._listener._c();\n    };\n    return Observer;\n}());\nvar FromObservable = (function () {\n    function FromObservable(observable) {\n        this.type = 'fromObservable';\n        this.ins = observable;\n        this.active = false;\n    }\n    FromObservable.prototype._start = function (out) {\n        this.out = out;\n        this.active = true;\n        this._sub = this.ins.subscribe(new Observer(out));\n        if (!this.active)\n            this._sub.unsubscribe();\n    };\n    FromObservable.prototype._stop = function () {\n        if (this._sub)\n            this._sub.unsubscribe();\n        this.active = false;\n    };\n    return FromObservable;\n}());\nvar Merge = (function () {\n    function Merge(insArr) {\n        this.type = 'merge';\n        this.insArr = insArr;\n        this.out = NO;\n        this.ac = 0;\n    }\n    Merge.prototype._start = function (out) {\n        this.out = out;\n        var s = this.insArr;\n        var L = s.length;\n        this.ac = L;\n        for (var i = 0; i < L; i++)\n            s[i]._add(this);\n    };\n    Merge.prototype._stop = function () {\n        var s = this.insArr;\n        var L = s.length;\n        for (var i = 0; i < L; i++)\n            s[i]._remove(this);\n        this.out = NO;\n    };\n    Merge.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._n(t);\n    };\n    Merge.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Merge.prototype._c = function () {\n        if (--this.ac <= 0) {\n            var u = this.out;\n            if (u === NO)\n                return;\n            u._c();\n        }\n    };\n    return Merge;\n}());\nvar CombineListener = (function () {\n    function CombineListener(i, out, p) {\n        this.i = i;\n        this.out = out;\n        this.p = p;\n        p.ils.push(this);\n    }\n    CombineListener.prototype._n = function (t) {\n        var p = this.p, out = this.out;\n        if (out === NO)\n            return;\n        if (p.up(t, this.i)) {\n            var a = p.vals;\n            var l = a.length;\n            var b = Array(l);\n            for (var i = 0; i < l; ++i)\n                b[i] = a[i];\n            out._n(b);\n        }\n    };\n    CombineListener.prototype._e = function (err) {\n        var out = this.out;\n        if (out === NO)\n            return;\n        out._e(err);\n    };\n    CombineListener.prototype._c = function () {\n        var p = this.p;\n        if (p.out === NO)\n            return;\n        if (--p.Nc === 0)\n            p.out._c();\n    };\n    return CombineListener;\n}());\nvar Combine = (function () {\n    function Combine(insArr) {\n        this.type = 'combine';\n        this.insArr = insArr;\n        this.out = NO;\n        this.ils = [];\n        this.Nc = this.Nn = 0;\n        this.vals = [];\n    }\n    Combine.prototype.up = function (t, i) {\n        var v = this.vals[i];\n        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;\n        this.vals[i] = t;\n        return Nn === 0;\n    };\n    Combine.prototype._start = function (out) {\n        this.out = out;\n        var s = this.insArr;\n        var n = this.Nc = this.Nn = s.length;\n        var vals = this.vals = new Array(n);\n        if (n === 0) {\n            out._n([]);\n            out._c();\n        }\n        else {\n            for (var i = 0; i < n; i++) {\n                vals[i] = NO;\n                s[i]._add(new CombineListener(i, out, this));\n            }\n        }\n    };\n    Combine.prototype._stop = function () {\n        var s = this.insArr;\n        var n = s.length;\n        var ils = this.ils;\n        for (var i = 0; i < n; i++)\n            s[i]._remove(ils[i]);\n        this.out = NO;\n        this.ils = [];\n        this.vals = [];\n    };\n    return Combine;\n}());\nvar FromArray = (function () {\n    function FromArray(a) {\n        this.type = 'fromArray';\n        this.a = a;\n    }\n    FromArray.prototype._start = function (out) {\n        var a = this.a;\n        for (var i = 0, n = a.length; i < n; i++)\n            out._n(a[i]);\n        out._c();\n    };\n    FromArray.prototype._stop = function () {\n    };\n    return FromArray;\n}());\nvar FromPromise = (function () {\n    function FromPromise(p) {\n        this.type = 'fromPromise';\n        this.on = false;\n        this.p = p;\n    }\n    FromPromise.prototype._start = function (out) {\n        var prod = this;\n        this.on = true;\n        this.p.then(function (v) {\n            if (prod.on) {\n                out._n(v);\n                out._c();\n            }\n        }, function (e) {\n            out._e(e);\n        }).then(noop, function (err) {\n            setTimeout(function () { throw err; });\n        });\n    };\n    FromPromise.prototype._stop = function () {\n        this.on = false;\n    };\n    return FromPromise;\n}());\nvar Periodic = (function () {\n    function Periodic(period) {\n        this.type = 'periodic';\n        this.period = period;\n        this.intervalID = -1;\n        this.i = 0;\n    }\n    Periodic.prototype._start = function (out) {\n        var self = this;\n        function intervalHandler() { out._n(self.i++); }\n        this.intervalID = setInterval(intervalHandler, this.period);\n    };\n    Periodic.prototype._stop = function () {\n        if (this.intervalID !== -1)\n            clearInterval(this.intervalID);\n        this.intervalID = -1;\n        this.i = 0;\n    };\n    return Periodic;\n}());\nvar Debug = (function () {\n    function Debug(ins, arg) {\n        this.type = 'debug';\n        this.ins = ins;\n        this.out = NO;\n        this.s = noop;\n        this.l = '';\n        if (typeof arg === 'string')\n            this.l = arg;\n        else if (typeof arg === 'function')\n            this.s = arg;\n    }\n    Debug.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    Debug.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n    };\n    Debug.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        var s = this.s, l = this.l;\n        if (s !== noop) {\n            try {\n                s(t);\n            }\n            catch (e) {\n                u._e(e);\n            }\n        }\n        else if (l)\n            console.log(l + ':', t);\n        else\n            console.log(t);\n        u._n(t);\n    };\n    Debug.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Debug.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return Debug;\n}());\nvar Drop = (function () {\n    function Drop(max, ins) {\n        this.type = 'drop';\n        this.ins = ins;\n        this.out = NO;\n        this.max = max;\n        this.dropped = 0;\n    }\n    Drop.prototype._start = function (out) {\n        this.out = out;\n        this.dropped = 0;\n        this.ins._add(this);\n    };\n    Drop.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n    };\n    Drop.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        if (this.dropped++ >= this.max)\n            u._n(t);\n    };\n    Drop.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Drop.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return Drop;\n}());\nvar EndWhenListener = (function () {\n    function EndWhenListener(out, op) {\n        this.out = out;\n        this.op = op;\n    }\n    EndWhenListener.prototype._n = function () {\n        this.op.end();\n    };\n    EndWhenListener.prototype._e = function (err) {\n        this.out._e(err);\n    };\n    EndWhenListener.prototype._c = function () {\n        this.op.end();\n    };\n    return EndWhenListener;\n}());\nvar EndWhen = (function () {\n    function EndWhen(o, ins) {\n        this.type = 'endWhen';\n        this.ins = ins;\n        this.out = NO;\n        this.o = o;\n        this.oil = NO_IL;\n    }\n    EndWhen.prototype._start = function (out) {\n        this.out = out;\n        this.o._add(this.oil = new EndWhenListener(out, this));\n        this.ins._add(this);\n    };\n    EndWhen.prototype._stop = function () {\n        this.ins._remove(this);\n        this.o._remove(this.oil);\n        this.out = NO;\n        this.oil = NO_IL;\n    };\n    EndWhen.prototype.end = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    EndWhen.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._n(t);\n    };\n    EndWhen.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    EndWhen.prototype._c = function () {\n        this.end();\n    };\n    return EndWhen;\n}());\nvar Filter = (function () {\n    function Filter(passes, ins) {\n        this.type = 'filter';\n        this.ins = ins;\n        this.out = NO;\n        this.f = passes;\n    }\n    Filter.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    Filter.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n    };\n    Filter.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        var r = _try(this, t, u);\n        if (r === NO || !r)\n            return;\n        u._n(t);\n    };\n    Filter.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Filter.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return Filter;\n}());\nvar FlattenListener = (function () {\n    function FlattenListener(out, op) {\n        this.out = out;\n        this.op = op;\n    }\n    FlattenListener.prototype._n = function (t) {\n        this.out._n(t);\n    };\n    FlattenListener.prototype._e = function (err) {\n        this.out._e(err);\n    };\n    FlattenListener.prototype._c = function () {\n        this.op.inner = NO;\n        this.op.less();\n    };\n    return FlattenListener;\n}());\nvar Flatten = (function () {\n    function Flatten(ins) {\n        this.type = 'flatten';\n        this.ins = ins;\n        this.out = NO;\n        this.open = true;\n        this.inner = NO;\n        this.il = NO_IL;\n    }\n    Flatten.prototype._start = function (out) {\n        this.out = out;\n        this.open = true;\n        this.inner = NO;\n        this.il = NO_IL;\n        this.ins._add(this);\n    };\n    Flatten.prototype._stop = function () {\n        this.ins._remove(this);\n        if (this.inner !== NO)\n            this.inner._remove(this.il);\n        this.out = NO;\n        this.open = true;\n        this.inner = NO;\n        this.il = NO_IL;\n    };\n    Flatten.prototype.less = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        if (!this.open && this.inner === NO)\n            u._c();\n    };\n    Flatten.prototype._n = function (s) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        var _a = this, inner = _a.inner, il = _a.il;\n        if (inner !== NO && il !== NO_IL)\n            inner._remove(il);\n        (this.inner = s)._add(this.il = new FlattenListener(u, this));\n    };\n    Flatten.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Flatten.prototype._c = function () {\n        this.open = false;\n        this.less();\n    };\n    return Flatten;\n}());\nvar Fold = (function () {\n    function Fold(f, seed, ins) {\n        var _this = this;\n        this.type = 'fold';\n        this.ins = ins;\n        this.out = NO;\n        this.f = function (t) { return f(_this.acc, t); };\n        this.acc = this.seed = seed;\n    }\n    Fold.prototype._start = function (out) {\n        this.out = out;\n        this.acc = this.seed;\n        out._n(this.acc);\n        this.ins._add(this);\n    };\n    Fold.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n        this.acc = this.seed;\n    };\n    Fold.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        var r = _try(this, t, u);\n        if (r === NO)\n            return;\n        u._n(this.acc = r);\n    };\n    Fold.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Fold.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return Fold;\n}());\nvar Last = (function () {\n    function Last(ins) {\n        this.type = 'last';\n        this.ins = ins;\n        this.out = NO;\n        this.has = false;\n        this.val = NO;\n    }\n    Last.prototype._start = function (out) {\n        this.out = out;\n        this.has = false;\n        this.ins._add(this);\n    };\n    Last.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n        this.val = NO;\n    };\n    Last.prototype._n = function (t) {\n        this.has = true;\n        this.val = t;\n    };\n    Last.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Last.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        if (this.has) {\n            u._n(this.val);\n            u._c();\n        }\n        else\n            u._e(new Error('last() failed because input stream completed'));\n    };\n    return Last;\n}());\nvar MapOp = (function () {\n    function MapOp(project, ins) {\n        this.type = 'map';\n        this.ins = ins;\n        this.out = NO;\n        this.f = project;\n    }\n    MapOp.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    MapOp.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n    };\n    MapOp.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        var r = _try(this, t, u);\n        if (r === NO)\n            return;\n        u._n(r);\n    };\n    MapOp.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    MapOp.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return MapOp;\n}());\nvar Remember = (function () {\n    function Remember(ins) {\n        this.type = 'remember';\n        this.ins = ins;\n        this.out = NO;\n    }\n    Remember.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(out);\n    };\n    Remember.prototype._stop = function () {\n        this.ins._remove(this.out);\n        this.out = NO;\n    };\n    return Remember;\n}());\nvar ReplaceError = (function () {\n    function ReplaceError(replacer, ins) {\n        this.type = 'replaceError';\n        this.ins = ins;\n        this.out = NO;\n        this.f = replacer;\n    }\n    ReplaceError.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    ReplaceError.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n    };\n    ReplaceError.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._n(t);\n    };\n    ReplaceError.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        try {\n            this.ins._remove(this);\n            (this.ins = this.f(err))._add(this);\n        }\n        catch (e) {\n            u._e(e);\n        }\n    };\n    ReplaceError.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return ReplaceError;\n}());\nvar StartWith = (function () {\n    function StartWith(ins, val) {\n        this.type = 'startWith';\n        this.ins = ins;\n        this.out = NO;\n        this.val = val;\n    }\n    StartWith.prototype._start = function (out) {\n        this.out = out;\n        this.out._n(this.val);\n        this.ins._add(out);\n    };\n    StartWith.prototype._stop = function () {\n        this.ins._remove(this.out);\n        this.out = NO;\n    };\n    return StartWith;\n}());\nvar Take = (function () {\n    function Take(max, ins) {\n        this.type = 'take';\n        this.ins = ins;\n        this.out = NO;\n        this.max = max;\n        this.taken = 0;\n    }\n    Take.prototype._start = function (out) {\n        this.out = out;\n        this.taken = 0;\n        if (this.max <= 0)\n            out._c();\n        else\n            this.ins._add(this);\n    };\n    Take.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = NO;\n    };\n    Take.prototype._n = function (t) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        var m = ++this.taken;\n        if (m < this.max)\n            u._n(t);\n        else if (m === this.max) {\n            u._n(t);\n            u._c();\n        }\n    };\n    Take.prototype._e = function (err) {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._e(err);\n    };\n    Take.prototype._c = function () {\n        var u = this.out;\n        if (u === NO)\n            return;\n        u._c();\n    };\n    return Take;\n}());\nvar Stream = (function () {\n    function Stream(producer) {\n        this._prod = producer || NO;\n        this._ils = [];\n        this._stopID = NO;\n        this._dl = NO;\n        this._d = false;\n        this._target = NO;\n        this._err = NO;\n    }\n    Stream.prototype._n = function (t) {\n        var a = this._ils;\n        var L = a.length;\n        if (this._d)\n            this._dl._n(t);\n        if (L == 1)\n            a[0]._n(t);\n        else if (L == 0)\n            return;\n        else {\n            var b = cp(a);\n            for (var i = 0; i < L; i++)\n                b[i]._n(t);\n        }\n    };\n    Stream.prototype._e = function (err) {\n        if (this._err !== NO)\n            return;\n        this._err = err;\n        var a = this._ils;\n        var L = a.length;\n        this._x();\n        if (this._d)\n            this._dl._e(err);\n        if (L == 1)\n            a[0]._e(err);\n        else if (L == 0)\n            return;\n        else {\n            var b = cp(a);\n            for (var i = 0; i < L; i++)\n                b[i]._e(err);\n        }\n        if (!this._d && L == 0)\n            throw this._err;\n    };\n    Stream.prototype._c = function () {\n        var a = this._ils;\n        var L = a.length;\n        this._x();\n        if (this._d)\n            this._dl._c();\n        if (L == 1)\n            a[0]._c();\n        else if (L == 0)\n            return;\n        else {\n            var b = cp(a);\n            for (var i = 0; i < L; i++)\n                b[i]._c();\n        }\n    };\n    Stream.prototype._x = function () {\n        if (this._ils.length === 0)\n            return;\n        if (this._prod !== NO)\n            this._prod._stop();\n        this._err = NO;\n        this._ils = [];\n    };\n    Stream.prototype._stopNow = function () {\n        // WARNING: code that calls this method should\n        // first check if this._prod is valid (not `NO`)\n        this._prod._stop();\n        this._err = NO;\n        this._stopID = NO;\n    };\n    Stream.prototype._add = function (il) {\n        var ta = this._target;\n        if (ta !== NO)\n            return ta._add(il);\n        var a = this._ils;\n        a.push(il);\n        if (a.length > 1)\n            return;\n        if (this._stopID !== NO) {\n            clearTimeout(this._stopID);\n            this._stopID = NO;\n        }\n        else {\n            var p = this._prod;\n            if (p !== NO)\n                p._start(this);\n        }\n    };\n    Stream.prototype._remove = function (il) {\n        var _this = this;\n        var ta = this._target;\n        if (ta !== NO)\n            return ta._remove(il);\n        var a = this._ils;\n        var i = a.indexOf(il);\n        if (i > -1) {\n            a.splice(i, 1);\n            if (this._prod !== NO && a.length <= 0) {\n                this._err = NO;\n                this._stopID = setTimeout(function () { return _this._stopNow(); });\n            }\n            else if (a.length === 1) {\n                this._pruneCycles();\n            }\n        }\n    };\n    // If all paths stemming from `this` stream eventually end at `this`\n    // stream, then we remove the single listener of `this` stream, to\n    // force it to end its execution and dispose resources. This method\n    // assumes as a precondition that this._ils has just one listener.\n    Stream.prototype._pruneCycles = function () {\n        if (this._hasNoSinks(this, []))\n            this._remove(this._ils[0]);\n    };\n    // Checks whether *there is no* path starting from `x` that leads to an end\n    // listener (sink) in the stream graph, following edges A->B where B is a\n    // listener of A. This means these paths constitute a cycle somehow. Is given\n    // a trace of all visited nodes so far.\n    Stream.prototype._hasNoSinks = function (x, trace) {\n        if (trace.indexOf(x) !== -1)\n            return true;\n        else if (x.out === this)\n            return true;\n        else if (x.out && x.out !== NO)\n            return this._hasNoSinks(x.out, trace.concat(x));\n        else if (x._ils) {\n            for (var i = 0, N = x._ils.length; i < N; i++)\n                if (!this._hasNoSinks(x._ils[i], trace.concat(x)))\n                    return false;\n            return true;\n        }\n        else\n            return false;\n    };\n    Stream.prototype.ctor = function () {\n        return this instanceof MemoryStream ? MemoryStream : Stream;\n    };\n    /**\n     * Adds a Listener to the Stream.\n     *\n     * @param {Listener} listener\n     */\n    Stream.prototype.addListener = function (listener) {\n        listener._n = listener.next || noop;\n        listener._e = listener.error || noop;\n        listener._c = listener.complete || noop;\n        this._add(listener);\n    };\n    /**\n     * Removes a Listener from the Stream, assuming the Listener was added to it.\n     *\n     * @param {Listener<T>} listener\n     */\n    Stream.prototype.removeListener = function (listener) {\n        this._remove(listener);\n    };\n    /**\n     * Adds a Listener to the Stream returning a Subscription to remove that\n     * listener.\n     *\n     * @param {Listener} listener\n     * @returns {Subscription}\n     */\n    Stream.prototype.subscribe = function (listener) {\n        this.addListener(listener);\n        return new StreamSub(this, listener);\n    };\n    /**\n     * Add interop between most.js and RxJS 5\n     *\n     * @returns {Stream}\n     */\n    Stream.prototype[symbol_observable_1.default] = function () {\n        return this;\n    };\n    /**\n     * Creates a new Stream given a Producer.\n     *\n     * @factory true\n     * @param {Producer} producer An optional Producer that dictates how to\n     * start, generate events, and stop the Stream.\n     * @return {Stream}\n     */\n    Stream.create = function (producer) {\n        if (producer) {\n            if (typeof producer.start !== 'function'\n                || typeof producer.stop !== 'function')\n                throw new Error('producer requires both start and stop functions');\n            internalizeProducer(producer); // mutates the input\n        }\n        return new Stream(producer);\n    };\n    /**\n     * Creates a new MemoryStream given a Producer.\n     *\n     * @factory true\n     * @param {Producer} producer An optional Producer that dictates how to\n     * start, generate events, and stop the Stream.\n     * @return {MemoryStream}\n     */\n    Stream.createWithMemory = function (producer) {\n        if (producer)\n            internalizeProducer(producer); // mutates the input\n        return new MemoryStream(producer);\n    };\n    /**\n     * Creates a Stream that does nothing when started. It never emits any event.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     *          never\n     * -----------------------\n     * ```\n     *\n     * @factory true\n     * @return {Stream}\n     */\n    Stream.never = function () {\n        return new Stream({ _start: noop, _stop: noop });\n    };\n    /**\n     * Creates a Stream that immediately emits the \"complete\" notification when\n     * started, and that's it.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * empty\n     * -|\n     * ```\n     *\n     * @factory true\n     * @return {Stream}\n     */\n    Stream.empty = function () {\n        return new Stream({\n            _start: function (il) { il._c(); },\n            _stop: noop,\n        });\n    };\n    /**\n     * Creates a Stream that immediately emits an \"error\" notification with the\n     * value you passed as the `error` argument when the stream starts, and that's\n     * it.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * throw(X)\n     * -X\n     * ```\n     *\n     * @factory true\n     * @param error The error event to emit on the created stream.\n     * @return {Stream}\n     */\n    Stream.throw = function (error) {\n        return new Stream({\n            _start: function (il) { il._e(error); },\n            _stop: noop,\n        });\n    };\n    /**\n     * Creates a stream from an Array, Promise, or an Observable.\n     *\n     * @factory true\n     * @param {Array|Promise|Observable} input The input to make a stream from.\n     * @return {Stream}\n     */\n    Stream.from = function (input) {\n        if (typeof input[symbol_observable_1.default] === 'function')\n            return Stream.fromObservable(input);\n        else if (typeof input.then === 'function')\n            return Stream.fromPromise(input);\n        else if (Array.isArray(input))\n            return Stream.fromArray(input);\n        throw new TypeError(\"Type of input to from() must be an Array, Promise, or Observable\");\n    };\n    /**\n     * Creates a Stream that immediately emits the arguments that you give to\n     * *of*, then completes.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * of(1,2,3)\n     * 123|\n     * ```\n     *\n     * @factory true\n     * @param a The first value you want to emit as an event on the stream.\n     * @param b The second value you want to emit as an event on the stream. One\n     * or more of these values may be given as arguments.\n     * @return {Stream}\n     */\n    Stream.of = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        return Stream.fromArray(items);\n    };\n    /**\n     * Converts an array to a stream. The returned stream will emit synchronously\n     * all the items in the array, and then complete.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * fromArray([1,2,3])\n     * 123|\n     * ```\n     *\n     * @factory true\n     * @param {Array} array The array to be converted as a stream.\n     * @return {Stream}\n     */\n    Stream.fromArray = function (array) {\n        return new Stream(new FromArray(array));\n    };\n    /**\n     * Converts a promise to a stream. The returned stream will emit the resolved\n     * value of the promise, and then complete. However, if the promise is\n     * rejected, the stream will emit the corresponding error.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * fromPromise( ----42 )\n     * -----------------42|\n     * ```\n     *\n     * @factory true\n     * @param {Promise} promise The promise to be converted as a stream.\n     * @return {Stream}\n     */\n    Stream.fromPromise = function (promise) {\n        return new Stream(new FromPromise(promise));\n    };\n    /**\n     * Converts an Observable into a Stream.\n     *\n     * @factory true\n     * @param {any} observable The observable to be converted as a stream.\n     * @return {Stream}\n     */\n    Stream.fromObservable = function (obs) {\n        if (obs.endWhen)\n            return obs;\n        return new Stream(new FromObservable(obs));\n    };\n    /**\n     * Creates a stream that periodically emits incremental numbers, every\n     * `period` milliseconds.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     *     periodic(1000)\n     * ---0---1---2---3---4---...\n     * ```\n     *\n     * @factory true\n     * @param {number} period The interval in milliseconds to use as a rate of\n     * emission.\n     * @return {Stream}\n     */\n    Stream.periodic = function (period) {\n        return new Stream(new Periodic(period));\n    };\n    Stream.prototype._map = function (project) {\n        return new (this.ctor())(new MapOp(project, this));\n    };\n    /**\n     * Transforms each event from the input Stream through a `project` function,\n     * to get a Stream that emits those transformed events.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --1---3--5-----7------\n     *    map(i => i * 10)\n     * --10--30-50----70-----\n     * ```\n     *\n     * @param {Function} project A function of type `(t: T) => U` that takes event\n     * `t` of type `T` from the input Stream and produces an event of type `U`, to\n     * be emitted on the output Stream.\n     * @return {Stream}\n     */\n    Stream.prototype.map = function (project) {\n        return this._map(project);\n    };\n    /**\n     * It's like `map`, but transforms each input event to always the same\n     * constant value on the output Stream.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --1---3--5-----7-----\n     *       mapTo(10)\n     * --10--10-10----10----\n     * ```\n     *\n     * @param projectedValue A value to emit on the output Stream whenever the\n     * input Stream emits any value.\n     * @return {Stream}\n     */\n    Stream.prototype.mapTo = function (projectedValue) {\n        var s = this.map(function () { return projectedValue; });\n        var op = s._prod;\n        op.type = 'mapTo';\n        return s;\n    };\n    /**\n     * Only allows events that pass the test given by the `passes` argument.\n     *\n     * Each event from the input stream is given to the `passes` function. If the\n     * function returns `true`, the event is forwarded to the output stream,\n     * otherwise it is ignored and not forwarded.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --1---2--3-----4-----5---6--7-8--\n     *     filter(i => i % 2 === 0)\n     * ------2--------4---------6----8--\n     * ```\n     *\n     * @param {Function} passes A function of type `(t: T) +> boolean` that takes\n     * an event from the input stream and checks if it passes, by returning a\n     * boolean.\n     * @return {Stream}\n     */\n    Stream.prototype.filter = function (passes) {\n        var p = this._prod;\n        if (p instanceof Filter)\n            return new Stream(new Filter(and(p.f, passes), p.ins));\n        return new Stream(new Filter(passes, this));\n    };\n    /**\n     * Lets the first `amount` many events from the input stream pass to the\n     * output stream, then makes the output stream complete.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --a---b--c----d---e--\n     *    take(3)\n     * --a---b--c|\n     * ```\n     *\n     * @param {number} amount How many events to allow from the input stream\n     * before completing the output stream.\n     * @return {Stream}\n     */\n    Stream.prototype.take = function (amount) {\n        return new (this.ctor())(new Take(amount, this));\n    };\n    /**\n     * Ignores the first `amount` many events from the input stream, and then\n     * after that starts forwarding events from the input stream to the output\n     * stream.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --a---b--c----d---e--\n     *       drop(3)\n     * --------------d---e--\n     * ```\n     *\n     * @param {number} amount How many events to ignore from the input stream\n     * before forwarding all events from the input stream to the output stream.\n     * @return {Stream}\n     */\n    Stream.prototype.drop = function (amount) {\n        return new Stream(new Drop(amount, this));\n    };\n    /**\n     * When the input stream completes, the output stream will emit the last event\n     * emitted by the input stream, and then will also complete.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --a---b--c--d----|\n     *       last()\n     * -----------------d|\n     * ```\n     *\n     * @return {Stream}\n     */\n    Stream.prototype.last = function () {\n        return new Stream(new Last(this));\n    };\n    /**\n     * Prepends the given `initial` value to the sequence of events emitted by the\n     * input stream. The returned stream is a MemoryStream, which means it is\n     * already `remember()`'d.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * ---1---2-----3---\n     *   startWith(0)\n     * 0--1---2-----3---\n     * ```\n     *\n     * @param initial The value or event to prepend.\n     * @return {MemoryStream}\n     */\n    Stream.prototype.startWith = function (initial) {\n        return new MemoryStream(new StartWith(this, initial));\n    };\n    /**\n     * Uses another stream to determine when to complete the current stream.\n     *\n     * When the given `other` stream emits an event or completes, the output\n     * stream will complete. Before that happens, the output stream will behaves\n     * like the input stream.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * ---1---2-----3--4----5----6---\n     *   endWhen( --------a--b--| )\n     * ---1---2-----3--4--|\n     * ```\n     *\n     * @param other Some other stream that is used to know when should the output\n     * stream of this operator complete.\n     * @return {Stream}\n     */\n    Stream.prototype.endWhen = function (other) {\n        return new (this.ctor())(new EndWhen(other, this));\n    };\n    /**\n     * \"Folds\" the stream onto itself.\n     *\n     * Combines events from the past throughout\n     * the entire execution of the input stream, allowing you to accumulate them\n     * together. It's essentially like `Array.prototype.reduce`. The returned\n     * stream is a MemoryStream, which means it is already `remember()`'d.\n     *\n     * The output stream starts by emitting the `seed` which you give as argument.\n     * Then, when an event happens on the input stream, it is combined with that\n     * seed value through the `accumulate` function, and the output value is\n     * emitted on the output stream. `fold` remembers that output value as `acc`\n     * (\"accumulator\"), and then when a new input event `t` happens, `acc` will be\n     * combined with that to produce the new `acc` and so forth.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * ------1-----1--2----1----1------\n     *   fold((acc, x) => acc + x, 3)\n     * 3-----4-----5--7----8----9------\n     * ```\n     *\n     * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that\n     * takes the previous accumulated value `acc` and the incoming event from the\n     * input stream and produces the new accumulated value.\n     * @param seed The initial accumulated value, of type `R`.\n     * @return {MemoryStream}\n     */\n    Stream.prototype.fold = function (accumulate, seed) {\n        return new MemoryStream(new Fold(accumulate, seed, this));\n    };\n    /**\n     * Replaces an error with another stream.\n     *\n     * When (and if) an error happens on the input stream, instead of forwarding\n     * that error to the output stream, *replaceError* will call the `replace`\n     * function which returns the stream that the output stream will replicate.\n     * And, in case that new stream also emits an error, `replace` will be called\n     * again to get another stream to start replicating.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --1---2-----3--4-----X\n     *   replaceError( () => --10--| )\n     * --1---2-----3--4--------10--|\n     * ```\n     *\n     * @param {Function} replace A function of type `(err) => Stream` that takes\n     * the error that occurred on the input stream or on the previous replacement\n     * stream and returns a new stream. The output stream will behave like the\n     * stream that this function returns.\n     * @return {Stream}\n     */\n    Stream.prototype.replaceError = function (replace) {\n        return new (this.ctor())(new ReplaceError(replace, this));\n    };\n    /**\n     * Flattens a \"stream of streams\", handling only one nested stream at a time\n     * (no concurrency).\n     *\n     * If the input stream is a stream that emits streams, then this operator will\n     * return an output stream which is a flat stream: emits regular events. The\n     * flattening happens without concurrency. It works like this: when the input\n     * stream emits a nested stream, *flatten* will start imitating that nested\n     * one. However, as soon as the next nested stream is emitted on the input\n     * stream, *flatten* will forget the previous nested one it was imitating, and\n     * will start imitating the new nested one.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --+--------+---------------\n     *   \\        \\\n     *    \\       ----1----2---3--\n     *    --a--b----c----d--------\n     *           flatten\n     * -----a--b------1----2---3--\n     * ```\n     *\n     * @return {Stream}\n     */\n    Stream.prototype.flatten = function () {\n        var p = this._prod;\n        return new Stream(new Flatten(this));\n    };\n    /**\n     * Passes the input stream to a custom operator, to produce an output stream.\n     *\n     * *compose* is a handy way of using an existing function in a chained style.\n     * Instead of writing `outStream = f(inStream)` you can write\n     * `outStream = inStream.compose(f)`.\n     *\n     * @param {function} operator A function that takes a stream as input and\n     * returns a stream as well.\n     * @return {Stream}\n     */\n    Stream.prototype.compose = function (operator) {\n        return operator(this);\n    };\n    /**\n     * Returns an output stream that behaves like the input stream, but also\n     * remembers the most recent event that happens on the input stream, so that a\n     * newly added listener will immediately receive that memorised event.\n     *\n     * @return {MemoryStream}\n     */\n    Stream.prototype.remember = function () {\n        return new MemoryStream(new Remember(this));\n    };\n    /**\n     * Returns an output stream that identically behaves like the input stream,\n     * but also runs a `spy` function fo each event, to help you debug your app.\n     *\n     * *debug* takes a `spy` function as argument, and runs that for each event\n     * happening on the input stream. If you don't provide the `spy` argument,\n     * then *debug* will just `console.log` each event. This helps you to\n     * understand the flow of events through some operator chain.\n     *\n     * Please note that if the output stream has no listeners, then it will not\n     * start, which means `spy` will never run because no actual event happens in\n     * that case.\n     *\n     * Marble diagram:\n     *\n     * ```text\n     * --1----2-----3-----4--\n     *         debug\n     * --1----2-----3-----4--\n     * ```\n     *\n     * @param {function} labelOrSpy A string to use as the label when printing\n     * debug information on the console, or a 'spy' function that takes an event\n     * as argument, and does not need to return anything.\n     * @return {Stream}\n     */\n    Stream.prototype.debug = function (labelOrSpy) {\n        return new (this.ctor())(new Debug(this, labelOrSpy));\n    };\n    /**\n     * *imitate* changes this current Stream to emit the same events that the\n     * `other` given Stream does. This method returns nothing.\n     *\n     * This method exists to allow one thing: **circular dependency of streams**.\n     * For instance, let's imagine that for some reason you need to create a\n     * circular dependency where stream `first$` depends on stream `second$`\n     * which in turn depends on `first$`:\n     *\n     * <!-- skip-example -->\n     * ```js\n     * import delay from 'xstream/extra/delay'\n     *\n     * var first$ = second$.map(x => x * 10).take(3);\n     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n     * ```\n     *\n     * However, that is invalid JavaScript, because `second$` is undefined\n     * on the first line. This is how *imitate* can help solve it:\n     *\n     * ```js\n     * import delay from 'xstream/extra/delay'\n     *\n     * var secondProxy$ = xs.create();\n     * var first$ = secondProxy$.map(x => x * 10).take(3);\n     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n     * secondProxy$.imitate(second$);\n     * ```\n     *\n     * We create `secondProxy$` before the others, so it can be used in the\n     * declaration of `first$`. Then, after both `first$` and `second$` are\n     * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell\n     * that they are \"the same\". `imitate` will not trigger the start of any\n     * stream, it just binds `secondProxy$` and `second$` together.\n     *\n     * The following is an example where `imitate()` is important in Cycle.js\n     * applications. A parent component contains some child components. A child\n     * has an action stream which is given to the parent to define its state:\n     *\n     * <!-- skip-example -->\n     * ```js\n     * const childActionProxy$ = xs.create();\n     * const parent = Parent({...sources, childAction$: childActionProxy$});\n     * const childAction$ = parent.state$.map(s => s.child.action$).flatten();\n     * childActionProxy$.imitate(childAction$);\n     * ```\n     *\n     * Note, though, that **`imitate()` does not support MemoryStreams**. If we\n     * would attempt to imitate a MemoryStream in a circular dependency, we would\n     * either get a race condition (where the symptom would be \"nothing happens\")\n     * or an infinite cyclic emission of values. It's useful to think about\n     * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to\n     * define a spreadsheet cell `A1` with a formula that depends on `B1` and\n     * cell `B1` defined with a formula that depends on `A1`.\n     *\n     * If you find yourself wanting to use `imitate()` with a\n     * MemoryStream, you should rework your code around `imitate()` to use a\n     * Stream instead. Look for the stream in the circular dependency that\n     * represents an event stream, and that would be a candidate for creating a\n     * proxy Stream which then imitates the target Stream.\n     *\n     * @param {Stream} target The other stream to imitate on the current one. Must\n     * not be a MemoryStream.\n     */\n    Stream.prototype.imitate = function (target) {\n        if (target instanceof MemoryStream)\n            throw new Error('A MemoryStream was given to imitate(), but it only ' +\n                'supports a Stream. Read more about this restriction here: ' +\n                'https://github.com/staltz/xstream#faq');\n        this._target = target;\n        for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)\n            target._add(ils[i]);\n        this._ils = [];\n    };\n    /**\n     * Forces the Stream to emit the given value to its listeners.\n     *\n     * As the name indicates, if you use this, you are most likely doing something\n     * The Wrong Way. Please try to understand the reactive way before using this\n     * method. Use it only when you know what you are doing.\n     *\n     * @param value The \"next\" value you want to broadcast to all listeners of\n     * this Stream.\n     */\n    Stream.prototype.shamefullySendNext = function (value) {\n        this._n(value);\n    };\n    /**\n     * Forces the Stream to emit the given error to its listeners.\n     *\n     * As the name indicates, if you use this, you are most likely doing something\n     * The Wrong Way. Please try to understand the reactive way before using this\n     * method. Use it only when you know what you are doing.\n     *\n     * @param {any} error The error you want to broadcast to all the listeners of\n     * this Stream.\n     */\n    Stream.prototype.shamefullySendError = function (error) {\n        this._e(error);\n    };\n    /**\n     * Forces the Stream to emit the \"completed\" event to its listeners.\n     *\n     * As the name indicates, if you use this, you are most likely doing something\n     * The Wrong Way. Please try to understand the reactive way before using this\n     * method. Use it only when you know what you are doing.\n     */\n    Stream.prototype.shamefullySendComplete = function () {\n        this._c();\n    };\n    /**\n     * Adds a \"debug\" listener to the stream. There can only be one debug\n     * listener, that's why this is 'setDebugListener'. To remove the debug\n     * listener, just call setDebugListener(null).\n     *\n     * A debug listener is like any other listener. The only difference is that a\n     * debug listener is \"stealthy\": its presence/absence does not trigger the\n     * start/stop of the stream (or the producer inside the stream). This is\n     * useful so you can inspect what is going on without changing the behavior\n     * of the program. If you have an idle stream and you add a normal listener to\n     * it, the stream will start executing. But if you set a debug listener on an\n     * idle stream, it won't start executing (not until the first normal listener\n     * is added).\n     *\n     * As the name indicates, we don't recommend using this method to build app\n     * logic. In fact, in most cases the debug operator works just fine. Only use\n     * this one if you know what you're doing.\n     *\n     * @param {Listener<T>} listener\n     */\n    Stream.prototype.setDebugListener = function (listener) {\n        if (!listener) {\n            this._d = false;\n            this._dl = NO;\n        }\n        else {\n            this._d = true;\n            listener._n = listener.next || noop;\n            listener._e = listener.error || noop;\n            listener._c = listener.complete || noop;\n            this._dl = listener;\n        }\n    };\n    return Stream;\n}());\n/**\n * Blends multiple streams together, emitting events from all of them\n * concurrently.\n *\n * *merge* takes multiple streams as arguments, and creates a stream that\n * behaves like each of the argument streams, in parallel.\n *\n * Marble diagram:\n *\n * ```text\n * --1----2-----3--------4---\n * ----a-----b----c---d------\n *            merge\n * --1-a--2--b--3-c---d--4---\n * ```\n *\n * @factory true\n * @param {Stream} stream1 A stream to merge together with other streams.\n * @param {Stream} stream2 A stream to merge together with other streams. Two\n * or more streams may be given as arguments.\n * @return {Stream}\n */\nStream.merge = function merge() {\n    var streams = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        streams[_i] = arguments[_i];\n    }\n    return new Stream(new Merge(streams));\n};\n/**\n * Combines multiple input streams together to return a stream whose events\n * are arrays that collect the latest events from each input stream.\n *\n * *combine* internally remembers the most recent event from each of the input\n * streams. When any of the input streams emits an event, that event together\n * with all the other saved events are combined into an array. That array will\n * be emitted on the output stream. It's essentially a way of joining together\n * the events from multiple streams.\n *\n * Marble diagram:\n *\n * ```text\n * --1----2-----3--------4---\n * ----a-----b-----c--d------\n *          combine\n * ----1a-2a-2b-3b-3c-3d-4d--\n * ```\n *\n * Note: to minimize garbage collection, *combine* uses the same array\n * instance for each emission.  If you need to compare emissions over time,\n * cache the values with `map` first:\n *\n * ```js\n * import pairwise from 'xstream/extra/pairwise'\n *\n * const stream1 = xs.of(1);\n * const stream2 = xs.of(2);\n *\n * xs.combine(stream1, stream2).map(\n *   combinedEmissions => ([ ...combinedEmissions ])\n * ).compose(pairwise)\n * ```\n *\n * @factory true\n * @param {Stream} stream1 A stream to combine together with other streams.\n * @param {Stream} stream2 A stream to combine together with other streams.\n * Multiple streams, not just two, may be given as arguments.\n * @return {Stream}\n */\nStream.combine = function combine() {\n    var streams = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        streams[_i] = arguments[_i];\n    }\n    return new Stream(new Combine(streams));\n};\nexports.Stream = Stream;\nvar MemoryStream = (function (_super) {\n    __extends(MemoryStream, _super);\n    function MemoryStream(producer) {\n        var _this = _super.call(this, producer) || this;\n        _this._has = false;\n        return _this;\n    }\n    MemoryStream.prototype._n = function (x) {\n        this._v = x;\n        this._has = true;\n        _super.prototype._n.call(this, x);\n    };\n    MemoryStream.prototype._add = function (il) {\n        var ta = this._target;\n        if (ta !== NO)\n            return ta._add(il);\n        var a = this._ils;\n        a.push(il);\n        if (a.length > 1) {\n            if (this._has)\n                il._n(this._v);\n            return;\n        }\n        if (this._stopID !== NO) {\n            if (this._has)\n                il._n(this._v);\n            clearTimeout(this._stopID);\n            this._stopID = NO;\n        }\n        else if (this._has)\n            il._n(this._v);\n        else {\n            var p = this._prod;\n            if (p !== NO)\n                p._start(this);\n        }\n    };\n    MemoryStream.prototype._stopNow = function () {\n        this._has = false;\n        _super.prototype._stopNow.call(this);\n    };\n    MemoryStream.prototype._x = function () {\n        this._has = false;\n        _super.prototype._x.call(this);\n    };\n    MemoryStream.prototype.map = function (project) {\n        return this._map(project);\n    };\n    MemoryStream.prototype.mapTo = function (projectedValue) {\n        return _super.prototype.mapTo.call(this, projectedValue);\n    };\n    MemoryStream.prototype.take = function (amount) {\n        return _super.prototype.take.call(this, amount);\n    };\n    MemoryStream.prototype.endWhen = function (other) {\n        return _super.prototype.endWhen.call(this, other);\n    };\n    MemoryStream.prototype.replaceError = function (replace) {\n        return _super.prototype.replaceError.call(this, replace);\n    };\n    MemoryStream.prototype.remember = function () {\n        return this;\n    };\n    MemoryStream.prototype.debug = function (labelOrSpy) {\n        return _super.prototype.debug.call(this, labelOrSpy);\n    };\n    return MemoryStream;\n}(Stream));\nexports.MemoryStream = MemoryStream;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Stream;\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/.markdown-doctest-setup.js":"var xstream = require('./index').default;\nvar eventsModule = require('events');\n\nfunction noop () {}\n\nclass FakeEventTarget {\n  constructor() {}\n\n  emit(x) {\n    if (typeof this.handler !== 'function') {\n      return;\n    }\n    this.handler.call(void 0, x);\n  }\n\n  addEventListener(e, handler, capture) {\n    this.event = e;\n    this.handler = handler;\n    this.capture = capture;\n  }\n\n  removeEventListener(e, handler, capture) {\n    this.removedEvent = e;\n    this.removedCapture = capture;\n    this.handler = this.event = this.capture = void 0;\n  }\n\n  dispatchEvent(event) {\n    return true;\n  }\n\n  querySelector() {\n    return this;\n  }\n}\n\nmodule.exports = {\n  require: {\n    xstream: xstream,\n    events: eventsModule,\n  },\n\n  regexRequire: {\n    'xstream/extra/(.*)': function (_, extra) {\n      return require('./extra/' + extra).default;\n    }\n  },\n\n  globals: {\n    xs: xstream,\n    stream: xstream.empty(),\n    A: xstream.never(),\n    B: xstream.never(),\n    setInterval: noop,\n    console: {\n      log: noop,\n      error: noop\n    },\n    document: new FakeEventTarget(),\n    listener: {\n      next: noop,\n      error: noop,\n      complete: noop\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/concat.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar ConcatProducer = (function () {\n    function ConcatProducer(streams) {\n        this.streams = streams;\n        this.type = 'concat';\n        this.out = null;\n        this.i = 0;\n    }\n    ConcatProducer.prototype._start = function (out) {\n        this.out = out;\n        this.streams[this.i]._add(this);\n    };\n    ConcatProducer.prototype._stop = function () {\n        var streams = this.streams;\n        if (this.i < streams.length) {\n            streams[this.i]._remove(this);\n        }\n        this.i = 0;\n        this.out = null;\n    };\n    ConcatProducer.prototype._n = function (t) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._n(t);\n    };\n    ConcatProducer.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    ConcatProducer.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        var streams = this.streams;\n        streams[this.i]._remove(this);\n        if (++this.i < streams.length) {\n            streams[this.i]._add(this);\n        }\n        else {\n            u._c();\n        }\n    };\n    return ConcatProducer;\n}());\n/**\n * Puts one stream after the other. *concat* is a factory that takes multiple\n * streams as arguments, and starts the `n+1`-th stream only when the `n`-th\n * stream has completed. It concatenates those streams together.\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * ...............--a-b-c--d-|\n *           concat\n * --1--2---3---4---a-b-c--d-|\n * ```\n *\n * Example:\n *\n * ```js\n * import concat from 'xstream/extra/concat'\n *\n * const streamA = xs.of('a', 'b', 'c')\n * const streamB = xs.of(10, 20, 30)\n * const streamC = xs.of('X', 'Y', 'Z')\n *\n * const outputStream = concat(streamA, streamB, streamC)\n *\n * outputStream.addListener({\n *   next: (x) => console.log(x),\n *   error: (err) => console.error(err),\n *   complete: () => console.log('concat completed'),\n * })\n * ```\n *\n * @factory true\n * @param {Stream} stream1 A stream to concatenate together with other streams.\n * @param {Stream} stream2 A stream to concatenate together with other streams. Two\n * or more streams may be given as arguments.\n * @return {Stream}\n */\nfunction concat() {\n    var streams = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        streams[_i] = arguments[_i];\n    }\n    return new index_1.Stream(new ConcatProducer(streams));\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = concat;\n//# sourceMappingURL=concat.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/debounce.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar DebounceOperator = (function () {\n    function DebounceOperator(dt, ins) {\n        this.dt = dt;\n        this.ins = ins;\n        this.type = 'debounce';\n        this.out = null;\n        this.id = null;\n    }\n    DebounceOperator.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    DebounceOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = null;\n        this.id = null;\n    };\n    DebounceOperator.prototype.clearInterval = function () {\n        var id = this.id;\n        if (id !== null) {\n            clearInterval(id);\n        }\n        this.id = null;\n    };\n    DebounceOperator.prototype._n = function (t) {\n        var _this = this;\n        var u = this.out;\n        if (!u)\n            return;\n        this.clearInterval();\n        this.id = setInterval(function () {\n            _this.clearInterval();\n            u._n(t);\n        }, this.dt);\n    };\n    DebounceOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        this.clearInterval();\n        u._e(err);\n    };\n    DebounceOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        this.clearInterval();\n        u._c();\n    };\n    return DebounceOperator;\n}());\n/**\n * Delays events until a certain amount of silence has passed. If that timespan\n * of silence is not met the event is dropped.\n *\n * Marble diagram:\n *\n * ```text\n * --1----2--3--4----5|\n *     debounce(60)\n * -----1----------4--|\n * ```\n *\n * Example:\n *\n * ```js\n * import fromDiagram from 'xstream/extra/fromDiagram'\n * import debounce from 'xstream/extra/debounce'\n *\n * const stream = fromDiagram('--1----2--3--4----5|')\n *  .compose(debounce(60))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 1\n * > 4\n * > completed\n * ```\n *\n * @param {number} period The amount of silence required in milliseconds.\n * @return {Stream}\n */\nfunction debounce(period) {\n    return function debounceOperator(ins) {\n        return new index_1.Stream(new DebounceOperator(period, ins));\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = debounce;\n//# sourceMappingURL=debounce.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/delay.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar DelayOperator = (function () {\n    function DelayOperator(dt, ins) {\n        this.dt = dt;\n        this.ins = ins;\n        this.type = 'delay';\n        this.out = null;\n    }\n    DelayOperator.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    DelayOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = null;\n    };\n    DelayOperator.prototype._n = function (t) {\n        var u = this.out;\n        if (!u)\n            return;\n        var id = setInterval(function () {\n            u._n(t);\n            clearInterval(id);\n        }, this.dt);\n    };\n    DelayOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        var id = setInterval(function () {\n            u._e(err);\n            clearInterval(id);\n        }, this.dt);\n    };\n    DelayOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        var id = setInterval(function () {\n            u._c();\n            clearInterval(id);\n        }, this.dt);\n    };\n    return DelayOperator;\n}());\n/**\n * Delays periodic events by a given time period.\n *\n * Marble diagram:\n *\n * ```text\n * 1----2--3--4----5|\n *     delay(60)\n * ---1----2--3--4----5|\n * ```\n *\n * Example:\n *\n * ```js\n * import fromDiagram from 'xstream/extra/fromDiagram'\n * import delay from 'xstream/extra/delay'\n *\n * const stream = fromDiagram('1----2--3--4----5|')\n *  .compose(delay(60))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 1  (after 60 ms)\n * > 2  (after 160 ms)\n * > 3  (after 220 ms)\n * > 4  (after 280 ms)\n * > 5  (after 380 ms)\n * > completed\n * ```\n *\n * @param {number} period The amount of silence required in milliseconds.\n * @return {Stream}\n */\nfunction delay(period) {\n    return function delayOperator(ins) {\n        return new index_1.Stream(new DelayOperator(period, ins));\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = delay;\n//# sourceMappingURL=delay.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/dropRepeats.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar empty = {};\nvar DropRepeatsOperator = (function () {\n    function DropRepeatsOperator(ins, fn) {\n        this.ins = ins;\n        this.fn = fn;\n        this.type = 'dropRepeats';\n        this.out = null;\n        this.v = empty;\n    }\n    DropRepeatsOperator.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    DropRepeatsOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = null;\n        this.v = empty;\n    };\n    DropRepeatsOperator.prototype.isEq = function (x, y) {\n        return this.fn ? this.fn(x, y) : x === y;\n    };\n    DropRepeatsOperator.prototype._n = function (t) {\n        var u = this.out;\n        if (!u)\n            return;\n        var v = this.v;\n        if (v !== empty && this.isEq(t, v))\n            return;\n        this.v = t;\n        u._n(t);\n    };\n    DropRepeatsOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    DropRepeatsOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        u._c();\n    };\n    return DropRepeatsOperator;\n}());\nexports.DropRepeatsOperator = DropRepeatsOperator;\n/**\n * Drops consecutive duplicate values in a stream.\n *\n * Marble diagram:\n *\n * ```text\n * --1--2--1--1--1--2--3--4--3--3|\n *     dropRepeats\n * --1--2--1--------2--3--4--3---|\n * ```\n *\n * Example:\n *\n * ```js\n * import dropRepeats from 'xstream/extra/dropRepeats'\n *\n * const stream = xs.of(1, 2, 1, 1, 1, 2, 3, 4, 3, 3)\n *   .compose(dropRepeats())\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 1\n * > 2\n * > 1\n * > 2\n * > 3\n * > 4\n * > 3\n * > completed\n * ```\n *\n * Example with a custom isEqual function:\n *\n * ```js\n * import dropRepeats from 'xstream/extra/dropRepeats'\n *\n * const stream = xs.of('a', 'b', 'a', 'A', 'B', 'b')\n *   .compose(dropRepeats((x, y) => x.toLowerCase() === y.toLowerCase()))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > a\n * > b\n * > a\n * > B\n * > completed\n * ```\n *\n * @param {Function} isEqual An optional function of type\n * `(x: T, y: T) => boolean` that takes an event from the input stream and\n * checks if it is equal to previous event, by returning a boolean.\n * @return {Stream}\n */\nfunction dropRepeats(isEqual) {\n    if (isEqual === void 0) { isEqual = void 0; }\n    return function dropRepeatsOperator(ins) {\n        return new index_1.Stream(new DropRepeatsOperator(ins, isEqual));\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = dropRepeats;\n//# sourceMappingURL=dropRepeats.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/dropUntil.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar OtherIL = (function () {\n    function OtherIL(out, op) {\n        this.out = out;\n        this.op = op;\n    }\n    OtherIL.prototype._n = function (t) {\n        this.op.up();\n    };\n    OtherIL.prototype._e = function (err) {\n        this.out._e(err);\n    };\n    OtherIL.prototype._c = function () {\n        this.op.up();\n    };\n    return OtherIL;\n}());\nvar DropUntilOperator = (function () {\n    function DropUntilOperator(o, // o = other\n        ins) {\n        this.o = o;\n        this.ins = ins;\n        this.type = 'dropUntil';\n        this.out = null;\n        this.oil = index_1.NO_IL; // oil = other InternalListener\n        this.on = false;\n    }\n    DropUntilOperator.prototype._start = function (out) {\n        this.out = out;\n        this.o._add(this.oil = new OtherIL(out, this));\n        this.ins._add(this);\n    };\n    DropUntilOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.o._remove(this.oil);\n        this.out = null;\n        this.oil = index_1.NO_IL;\n    };\n    DropUntilOperator.prototype.up = function () {\n        this.on = true;\n        this.o._remove(this.oil);\n        this.oil = index_1.NO_IL;\n    };\n    DropUntilOperator.prototype._n = function (t) {\n        var u = this.out;\n        if (!u)\n            return;\n        if (!this.on)\n            return;\n        u._n(t);\n    };\n    DropUntilOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    DropUntilOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        this.up();\n        u._c();\n    };\n    return DropUntilOperator;\n}());\nexports.DropUntilOperator = DropUntilOperator;\n/**\n * Starts emitting the input stream when another stream emits a next event. The\n * output stream will complete if/when the other stream completes.\n *\n * Marble diagram:\n *\n * ```text\n * ---1---2-----3--4----5----6---\n *   dropUntil( --------a--b--| )\n * ---------------------5----6|\n * ```\n *\n * Example:\n *\n * ```js\n * import dropUntil from 'xstream/extra/dropUntil'\n *\n * const other = xs.periodic(220).take(1)\n *\n * const stream = xs.periodic(50)\n *   .take(6)\n *   .compose(dropUntil(other))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 4\n * > 5\n * > completed\n * ```\n *\n * #### Arguments:\n *\n * @param {Stream} other Some other stream that is used to know when should the\n * output stream of this operator start emitting.\n * @return {Stream}\n */\nfunction dropUntil(other) {\n    return function dropUntilOperator(ins) {\n        return new index_1.Stream(new DropUntilOperator(other, ins));\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = dropUntil;\n//# sourceMappingURL=dropUntil.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/flattenConcurrently.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar FCIL = (function () {\n    function FCIL(out, op) {\n        this.out = out;\n        this.op = op;\n    }\n    FCIL.prototype._n = function (t) {\n        this.out._n(t);\n    };\n    FCIL.prototype._e = function (err) {\n        this.out._e(err);\n    };\n    FCIL.prototype._c = function () {\n        this.op.less();\n    };\n    return FCIL;\n}());\nvar FlattenConcOperator = (function () {\n    function FlattenConcOperator(ins) {\n        this.ins = ins;\n        this.type = 'flattenConcurrently';\n        this.active = 1; // number of outers and inners that have not yet ended\n        this.out = null;\n    }\n    FlattenConcOperator.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    FlattenConcOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.active = 1;\n        this.out = null;\n    };\n    FlattenConcOperator.prototype.less = function () {\n        if (--this.active === 0) {\n            var u = this.out;\n            if (!u)\n                return;\n            u._c();\n        }\n    };\n    FlattenConcOperator.prototype._n = function (s) {\n        var u = this.out;\n        if (!u)\n            return;\n        this.active++;\n        s._add(new FCIL(u, this));\n    };\n    FlattenConcOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    FlattenConcOperator.prototype._c = function () {\n        this.less();\n    };\n    return FlattenConcOperator;\n}());\nexports.FlattenConcOperator = FlattenConcOperator;\n/**\n * Flattens a \"stream of streams\", handling multiple concurrent nested streams\n * simultaneously.\n *\n * If the input stream is a stream that emits streams, then this operator will\n * return an output stream which is a flat stream: emits regular events. The\n * flattening happens concurrently. It works like this: when the input stream\n * emits a nested stream, *flattenConcurrently* will start imitating that\n * nested one. When the next nested stream is emitted on the input stream,\n * *flattenConcurrently* will also imitate that new one, but will continue to\n * imitate the previous nested streams as well.\n *\n * Marble diagram:\n *\n * ```text\n * --+--------+---------------\n *   \\        \\\n *    \\       ----1----2---3--\n *    --a--b----c----d--------\n *     flattenConcurrently\n * -----a--b----c-1--d-2---3--\n * ```\n *\n * @return {Stream}\n */\nfunction flattenConcurrently(ins) {\n    return new index_1.Stream(new FlattenConcOperator(ins));\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = flattenConcurrently;\n//# sourceMappingURL=flattenConcurrently.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/flattenSequentially.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar FSInner = (function () {\n    function FSInner(out, op) {\n        this.out = out;\n        this.op = op;\n    }\n    FSInner.prototype._n = function (t) {\n        this.out._n(t);\n    };\n    FSInner.prototype._e = function (err) {\n        this.out._e(err);\n    };\n    FSInner.prototype._c = function () {\n        this.op.less();\n    };\n    return FSInner;\n}());\nvar FlattenSeqOperator = (function () {\n    function FlattenSeqOperator(ins) {\n        this.type = 'flattenSequentially';\n        this.ins = ins;\n        this.out = null;\n        this.open = true;\n        this.active = null;\n        this.activeIL = null;\n        this.seq = [];\n    }\n    FlattenSeqOperator.prototype._start = function (out) {\n        this.out = out;\n        this.open = true;\n        this.active = null;\n        this.activeIL = new FSInner(out, this);\n        this.seq = [];\n        this.ins._add(this);\n    };\n    FlattenSeqOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        if (this.active && this.activeIL) {\n            this.active._remove(this.activeIL);\n        }\n        this.open = true;\n        this.active = null;\n        this.activeIL = null;\n        this.seq = [];\n        this.out = null;\n    };\n    FlattenSeqOperator.prototype.less = function () {\n        this.active = null;\n        var seq = this.seq;\n        if (seq.length > 0) {\n            this._n(seq.shift());\n        }\n        if (!this.open && !this.active) {\n            this.out._c();\n        }\n    };\n    FlattenSeqOperator.prototype._n = function (s) {\n        var u = this.out;\n        if (!u)\n            return;\n        if (this.active) {\n            this.seq.push(s);\n        }\n        else {\n            this.active = s;\n            s._add(this.activeIL);\n        }\n    };\n    FlattenSeqOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    FlattenSeqOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        this.open = false;\n        if (!this.active && this.seq.length === 0) {\n            u._c();\n        }\n    };\n    return FlattenSeqOperator;\n}());\nexports.FlattenSeqOperator = FlattenSeqOperator;\n/**\n * Flattens a \"stream of streams\", handling only one nested stream at a time,\n * with no concurrency, but does not drop nested streams like `flatten` does.\n *\n * If the input stream is a stream that emits streams, then this operator will\n * return an output stream which is a flat stream: emits regular events. The\n * flattening happens sequentially and without concurrency. It works like this:\n * when the input stream emits a nested stream, *flattenSequentially* will start\n * imitating that nested one. When the next nested stream is emitted on the\n * input stream, *flattenSequentially* will keep that in a buffer, and only\n * start imitating it once the previous nested stream completes.\n *\n * In essence, `flattenSequentially` concatenates all nested streams.\n *\n * Marble diagram:\n *\n * ```text\n * --+--------+-------------------------\n *   \\        \\\n *    \\       ----1----2---3--|\n *    --a--b----c----d--|\n *          flattenSequentially\n * -----a--b----c----d------1----2---3--\n * ```\n *\n * @return {Stream}\n */\nfunction flattenSequentially(ins) {\n    return new index_1.Stream(new FlattenSeqOperator(ins));\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = flattenSequentially;\n//# sourceMappingURL=flattenSequentially.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/fromDiagram.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar DiagramProducer = (function () {\n    function DiagramProducer(diagram, opt) {\n        this.diagram = diagram.trim();\n        this.errorVal = (opt && opt.errorValue) ? opt.errorValue : '#';\n        this.timeUnit = (opt && opt.timeUnit) ? opt.timeUnit : 20;\n        this.values = (opt && opt.values) ? opt.values : {};\n        this.tasks = [];\n    }\n    DiagramProducer.prototype._start = function (out) {\n        var L = this.diagram.length;\n        for (var i = 0; i < L; i++) {\n            var c = this.diagram[i];\n            var time = this.timeUnit * i;\n            switch (c) {\n                case '-':\n                    break;\n                case '#':\n                    this.schedule({ type: 'error', value: this.errorVal, time: time }, out);\n                    break;\n                case '|':\n                    this.schedule({ type: 'complete', time: time }, out);\n                    break;\n                default:\n                    var val = this.values.hasOwnProperty(c) ? this.values[c] : c;\n                    this.schedule({ type: 'next', value: val, time: time }, out);\n                    break;\n            }\n        }\n    };\n    DiagramProducer.prototype.schedule = function (notification, out) {\n        var id = setInterval(function () {\n            switch (notification.type) {\n                case 'next':\n                    out._n(notification.value);\n                    break;\n                case 'error':\n                    out._e(notification.value);\n                    break;\n                case 'complete':\n                    out._c();\n                    break;\n            }\n            clearInterval(id);\n        }, notification.time);\n    };\n    DiagramProducer.prototype._stop = function () {\n        this.tasks.forEach(function (id) { return clearInterval(id); });\n    };\n    return DiagramProducer;\n}());\nexports.DiagramProducer = DiagramProducer;\n/**\n * Creates a real stream out of an ASCII drawing of a stream. Each string\n * character represents an amount of time passed (by default, 20 milliseconds).\n * `-` characters represent nothing special, `|` is a symbol to mark the\n * completion of the stream, `#` is an error on the stream, and any other\n * character is a \"next\" event.\n *\n * Example:\n *\n * ```js\n * import fromDiagram from 'xstream/extra/fromDiagram'\n *\n * const stream = fromDiagram('--a--b---c-d--|')\n *\n * stream.addListener({\n *   next: (x) => console.log(x),\n *   error: (err) => console.error(err),\n *   complete: () => console.log('concat completed'),\n * })\n * ```\n *\n * The character `a` represent emission of the event `'a'`, a string. If you\n * want to emit something else than a string, you need to provide those values\n * in the options argument.\n *\n * Example:\n *\n * ```js\n * import fromDiagram from 'xstream/extra/fromDiagram'\n *\n * const stream = fromDiagram('--a--b---c-d--|', {\n *   values: {a: 10, b: 20, c: 30, d: 40}\n * })\n *\n * stream.addListener({\n *   next: (x) => console.log(x),\n *   error: (err) => console.error(err),\n *   complete: () => console.log('concat completed'),\n * })\n * ```\n *\n * That way, the stream will emit the numbers 10, 20, 30, 40. The `options`\n * argument may also take `timeUnit`, a number to configure how many\n * milliseconds does each represents, and `errorValue`, a value to send out as\n * the error which `#` represents.\n *\n * @factory true\n * @param {string} diagram A string representing a timeline of values, error,\n * or complete notifications that should happen on the output stream.\n * @param options An options object that allows you to configure some additional\n * details of the creation of the stream.\n * @return {Stream}\n */\nfunction fromDiagram(diagram, options) {\n    return new index_1.Stream(new DiagramProducer(diagram, options));\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = fromDiagram;\n//# sourceMappingURL=fromDiagram.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/fromEvent.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar DOMEventProducer = (function () {\n    function DOMEventProducer(node, eventType, useCapture) {\n        this.node = node;\n        this.eventType = eventType;\n        this.useCapture = useCapture;\n        this.type = 'fromEvent';\n    }\n    DOMEventProducer.prototype._start = function (out) {\n        this.listener = function (e) { return out._n(e); };\n        this.node.addEventListener(this.eventType, this.listener, this.useCapture);\n    };\n    DOMEventProducer.prototype._stop = function () {\n        this.node.removeEventListener(this.eventType, this.listener, this.useCapture);\n        this.listener = null;\n    };\n    return DOMEventProducer;\n}());\nexports.DOMEventProducer = DOMEventProducer;\nvar NodeEventProducer = (function () {\n    function NodeEventProducer(node, eventName) {\n        this.node = node;\n        this.eventName = eventName;\n        this.type = 'fromEvent';\n    }\n    NodeEventProducer.prototype._start = function (out) {\n        this.listener = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return (args.length > 1) ? out._n(args) : out._n(args[0]);\n        };\n        this.node.addListener(this.eventName, this.listener);\n    };\n    NodeEventProducer.prototype._stop = function () {\n        this.node.removeListener(this.eventName, this.listener);\n        this.listener = null;\n    };\n    return NodeEventProducer;\n}());\nexports.NodeEventProducer = NodeEventProducer;\nfunction isEmitter(element) {\n    return element.emit && element.addListener;\n}\n/**\n * Creates a stream based on either:\n * - DOM events with the name `eventName` from a provided target node\n * - Events with the name `eventName` from a provided NodeJS EventEmitter\n *\n * When creating a stream from EventEmitters, if the source event has more than\n * one argument all the arguments will be aggregated into an array in the\n * result stream.\n *\n * Marble diagram:\n *\n * ```text\n *   fromEvent(element, eventName)\n * ---ev--ev----ev---------------\n * ```\n *\n * Examples:\n *\n * ```js\n * import fromEvent from 'xstream/extra/fromEvent'\n *\n * const stream = fromEvent(document.querySelector('.button'), 'click')\n *   .mapTo('Button clicked!')\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 'Button clicked!'\n * > 'Button clicked!'\n * > 'Button clicked!'\n * ```\n *\n * ```js\n * import fromEvent from 'xstream/extra/fromEvent'\n * import {EventEmitter} from 'events'\n *\n * const MyEmitter = new EventEmitter()\n * const stream = fromEvent(MyEmitter, 'foo')\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n *\n * MyEmitter.emit('foo', 'bar')\n * ```\n *\n * ```text\n * > 'bar'\n * ```\n *\n * ```js\n * import fromEvent from 'xstream/extra/fromEvent'\n * import {EventEmitter} from 'events'\n *\n * const MyEmitter = new EventEmitter()\n * const stream = fromEvent(MyEmitter, 'foo')\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n *\n * MyEmitter.emit('foo', 'bar', 'baz', 'buzz')\n * ```\n *\n * ```text\n * > ['bar', 'baz', 'buzz']\n * ```\n *\n * @param {EventTarget|EventEmitter} element The element upon which to listen.\n * @param {string} eventName The name of the event for which to listen.\n * @param {boolean?} useCapture An optional boolean that indicates that events of\n * this type will be dispatched to the registered listener before being\n * dispatched to any EventTarget beneath it in the DOM tree. Defaults to false.\n * @return {Stream}\n */\nfunction fromEvent(element, eventName, useCapture) {\n    if (useCapture === void 0) { useCapture = false; }\n    if (isEmitter(element)) {\n        return new index_1.Stream(new NodeEventProducer(element, eventName));\n    }\n    else {\n        return new index_1.Stream(new DOMEventProducer(element, eventName, useCapture));\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = fromEvent;\n//# sourceMappingURL=fromEvent.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/pairwise.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar PairwiseOperator = (function () {\n    function PairwiseOperator(ins) {\n        this.ins = ins;\n        this.type = 'pairwise';\n        this.val = null;\n        this.has = false;\n        this.out = null;\n    }\n    PairwiseOperator.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    PairwiseOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.has = false;\n        this.out = null;\n        this.val = null;\n    };\n    PairwiseOperator.prototype._n = function (t) {\n        var u = this.out;\n        if (!u)\n            return;\n        if (this.has) {\n            var prev = this.val;\n            this.val = t;\n            u._n([prev, t]);\n        }\n        else {\n            this.val = t;\n            this.has = true;\n        }\n    };\n    PairwiseOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    PairwiseOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        u._c();\n    };\n    return PairwiseOperator;\n}());\n/**\n * Group consecutive pairs of events as arrays. Each array has two items.\n *\n * Marble diagram:\n *\n * ```text\n * ---1---2-----3-----4-----5--------|\n *       pairwise\n * -------[1,2]-[2,3]-[3,4]-[4,5]----|\n * ```\n *\n * Example:\n *\n * ```js\n * import pairwise from 'xstream/extra/pairwise'\n *\n * const stream = xs.of(1, 2, 3, 4, 5, 6).compose(pairwise)\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > [1,2]\n * > [2,3]\n * > [3,4]\n * > [4,5]\n * > [5,6]\n * > completed\n * ```\n *\n * @return {Stream}\n */\nfunction pairwise(ins) {\n    return new index_1.Stream(new PairwiseOperator(ins));\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = pairwise;\n//# sourceMappingURL=pairwise.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/sampleCombine.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar NO = {};\nvar SampleCombineListener = (function () {\n    function SampleCombineListener(i, p) {\n        this.i = i;\n        this.p = p;\n        p.ils[i] = this;\n    }\n    SampleCombineListener.prototype._n = function (t) {\n        var p = this.p;\n        if (p.out === NO)\n            return;\n        p.up(t, this.i);\n    };\n    SampleCombineListener.prototype._e = function (err) {\n        this.p._e(err);\n    };\n    SampleCombineListener.prototype._c = function () {\n        this.p.down(this.i, this);\n    };\n    return SampleCombineListener;\n}());\nexports.SampleCombineListener = SampleCombineListener;\nvar SampleCombineOperator = (function () {\n    function SampleCombineOperator(ins, streams) {\n        this.type = 'sampleCombine';\n        this.ins = ins;\n        this.others = streams;\n        this.out = NO;\n        this.ils = [];\n        this.Nn = 0;\n        this.vals = [];\n    }\n    SampleCombineOperator.prototype._start = function (out) {\n        this.out = out;\n        var s = this.others;\n        var n = this.Nn = s.length;\n        var vals = this.vals = new Array(n);\n        for (var i = 0; i < n; i++) {\n            vals[i] = NO;\n            s[i]._add(new SampleCombineListener(i, this));\n        }\n        this.ins._add(this);\n    };\n    SampleCombineOperator.prototype._stop = function () {\n        var s = this.others;\n        var n = s.length;\n        var ils = this.ils;\n        this.ins._remove(this);\n        for (var i = 0; i < n; i++) {\n            s[i]._remove(ils[i]);\n        }\n        this.out = NO;\n        this.vals = [];\n        this.ils = [];\n    };\n    SampleCombineOperator.prototype._n = function (t) {\n        var out = this.out;\n        if (out === NO)\n            return;\n        if (this.Nn > 0)\n            return;\n        out._n([t].concat(this.vals));\n    };\n    SampleCombineOperator.prototype._e = function (err) {\n        var out = this.out;\n        if (out === NO)\n            return;\n        out._e(err);\n    };\n    SampleCombineOperator.prototype._c = function () {\n        var out = this.out;\n        if (out === NO)\n            return;\n        out._c();\n    };\n    SampleCombineOperator.prototype.up = function (t, i) {\n        var v = this.vals[i];\n        if (this.Nn > 0 && v === NO) {\n            this.Nn--;\n        }\n        this.vals[i] = t;\n    };\n    SampleCombineOperator.prototype.down = function (i, l) {\n        this.others[i]._remove(l);\n    };\n    return SampleCombineOperator;\n}());\nexports.SampleCombineOperator = SampleCombineOperator;\nvar sampleCombine;\n/**\n *\n * Combines a source stream with multiple other streams. The result stream\n * will emit the latest events from all input streams, but only when the\n * source stream emits.\n *\n * If the source, or any input stream, throws an error, the result stream\n * will propagate the error. If any input streams end, their final emitted\n * value will remain in the array of any subsequent events from the result\n * stream.\n *\n * The result stream will only complete upon completion of the source stream.\n *\n * Marble diagram:\n *\n * ```text\n * --1----2-----3--------4--- (source)\n * ----a-----b-----c--d------ (other)\n *      sampleCombine\n * -------2a----3b-------4d--\n * ```\n *\n * Examples:\n *\n * ```js\n * import sampleCombine from 'xstream/extra/sampleCombine'\n * import xs from 'xstream'\n *\n * const sampler = xs.periodic(1000).take(3)\n * const other = xs.periodic(100)\n *\n * const stream = sampler.compose(sampleCombine(other))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > [0, 8]\n * > [1, 18]\n * > [2, 28]\n * ```\n *\n * ```js\n * import sampleCombine from 'xstream/extra/sampleCombine'\n * import xs from 'xstream'\n *\n * const sampler = xs.periodic(1000).take(3)\n * const other = xs.periodic(100).take(2)\n *\n * const stream = sampler.compose(sampleCombine(other))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > [0, 1]\n * > [1, 1]\n * > [2, 1]\n * ```\n *\n * @param {...Stream} streams One or more streams to combine with the sampler\n * stream.\n * @return {Stream}\n */\nsampleCombine = function sampleCombine() {\n    var streams = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        streams[_i] = arguments[_i];\n    }\n    return function sampleCombineOperator(sampler) {\n        return new index_1.Stream(new SampleCombineOperator(sampler, streams));\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = sampleCombine;\n//# sourceMappingURL=sampleCombine.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/split.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar SeparatorIL = (function () {\n    function SeparatorIL(out, op) {\n        this.out = out;\n        this.op = op;\n    }\n    SeparatorIL.prototype._n = function (t) {\n        this.op.up();\n    };\n    SeparatorIL.prototype._e = function (err) {\n        this.out._e(err);\n    };\n    SeparatorIL.prototype._c = function () {\n        this.op.curr._c();\n        this.out._c();\n    };\n    return SeparatorIL;\n}());\nvar SplitOperator = (function () {\n    function SplitOperator(s, // s = separator\n        ins) {\n        this.s = s;\n        this.ins = ins;\n        this.type = 'split';\n        this.curr = new index_1.Stream();\n        this.out = null;\n        this.sil = index_1.NO_IL; // sil = separator InternalListener\n    }\n    SplitOperator.prototype._start = function (out) {\n        this.out = out;\n        this.s._add(this.sil = new SeparatorIL(out, this));\n        this.ins._add(this);\n        out._n(this.curr);\n    };\n    SplitOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.s._remove(this.sil);\n        this.curr = new index_1.Stream();\n        this.out = null;\n        this.sil = index_1.NO_IL;\n    };\n    SplitOperator.prototype.up = function () {\n        this.curr._c();\n        this.out._n(this.curr = new index_1.Stream());\n    };\n    SplitOperator.prototype._n = function (t) {\n        if (!this.out)\n            return;\n        this.curr._n(t);\n    };\n    SplitOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        u._e(err);\n    };\n    SplitOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        this.curr._c();\n        u._c();\n    };\n    return SplitOperator;\n}());\nexports.SplitOperator = SplitOperator;\n/**\n * Splits a stream using a separator stream. Returns a stream that emits\n * streams.\n *\n * Marble diagram:\n *\n * ```text\n * --1--2--3--4--5--6--7--8--9|\n *  split( --a----b--- )\n * ---------------------------|\n *   :        :    :\n *   1--2--3-|:    :\n *            4--5|:\n *                 -6--7--8--9|\n * ```\n *\n * Example:\n *\n * ```js\n * import split from 'xstream/extra/split'\n * import concat from 'xstream/extra/concat'\n *\n * const source = xs.periodic(50).take(10)\n * const separator = concat(xs.periodic(167).take(2), xs.never())\n * const result = source.compose(split(separator))\n *\n * result.addListener({\n *   next: stream => {\n *     stream.addListener({\n *       next: i => console.log(i),\n *       error: err => console.error(err),\n *       complete: () => console.log('inner completed')\n *     })\n *   },\n *   error: err => console.error(err),\n *   complete: () => console.log('outer completed')\n * })\n * ```\n *\n * ```text\n * > 0\n * > 1\n * > 2\n * > inner completed\n * > 3\n * > 4\n * > 5\n * > inner completed\n * > 6\n * > 7\n * > 8\n * > 9\n * > inner completed\n * > outer completed\n * ```\n *\n * @param {Stream} separator Some other stream that is used to know when to\n * split the output stream.\n * @return {Stream}\n */\nfunction split(separator) {\n    return function splitOperator(ins) {\n        return new index_1.Stream(new SplitOperator(separator, ins));\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = split;\n//# sourceMappingURL=split.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/throttle.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar ThrottleOperator = (function () {\n    function ThrottleOperator(dt, ins) {\n        this.dt = dt;\n        this.ins = ins;\n        this.type = 'throttle';\n        this.out = null;\n        this.id = null;\n    }\n    ThrottleOperator.prototype._start = function (out) {\n        this.out = out;\n        this.ins._add(this);\n    };\n    ThrottleOperator.prototype._stop = function () {\n        this.ins._remove(this);\n        this.out = null;\n        this.id = null;\n    };\n    ThrottleOperator.prototype.clearInterval = function () {\n        var id = this.id;\n        if (id !== null) {\n            clearInterval(id);\n        }\n        this.id = null;\n    };\n    ThrottleOperator.prototype._n = function (t) {\n        var _this = this;\n        var u = this.out;\n        if (!u)\n            return;\n        if (this.id)\n            return;\n        u._n(t);\n        this.id = setInterval(function () {\n            _this.clearInterval();\n        }, this.dt);\n    };\n    ThrottleOperator.prototype._e = function (err) {\n        var u = this.out;\n        if (!u)\n            return;\n        this.clearInterval();\n        u._e(err);\n    };\n    ThrottleOperator.prototype._c = function () {\n        var u = this.out;\n        if (!u)\n            return;\n        this.clearInterval();\n        u._c();\n    };\n    return ThrottleOperator;\n}());\n/**\n * Emits event and drops subsequent events until a certain amount of silence has passed.\n *\n * Marble diagram:\n *\n * ```text\n * --1-2-----3--4----5|\n *     throttle(60)\n * --1-------3-------5-|\n * ```\n *\n * Example:\n *\n * ```js\n * import fromDiagram from 'xstream/extra/fromDiagram'\n * import throttle from 'xstream/extra/throttle'\n *\n * const stream = fromDiagram('--1-2-----3--4----5|')\n *  .compose(throttle(60))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 1\n * > 3\n * > 5\n * > completed\n * ```\n *\n * @param {number} period The amount of silence required in milliseconds.\n * @return {Stream}\n */\nfunction throttle(period) {\n    return function throttleOperator(ins) {\n        return new index_1.Stream(new ThrottleOperator(period, ins));\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = throttle;\n//# sourceMappingURL=throttle.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/extra/tween.js":"\"use strict\";\nvar index_1 = require(\"../index\");\nvar concat_1 = require(\"./concat\");\nfunction interpolate(y, from, to) {\n    return (from * (1 - y) + to * y);\n}\nfunction flip(fn) {\n    return function (x) { return 1 - fn(1 - x); };\n}\nfunction createEasing(fn) {\n    var fnFlipped = flip(fn);\n    return {\n        easeIn: function (x, from, to) {\n            return interpolate(fn(x), from, to);\n        },\n        easeOut: function (x, from, to) {\n            return interpolate(fnFlipped(x), from, to);\n        },\n        easeInOut: function (x, from, to) {\n            var y = (x < 0.5) ?\n                (fn(2 * x) * 0.5) :\n                (0.5 + fnFlipped(2 * (x - 0.5)) * 0.5);\n            return interpolate(y, from, to);\n        }\n    };\n}\n;\nvar easingPower2 = createEasing(function (x) { return x * x; });\nvar easingPower3 = createEasing(function (x) { return x * x * x; });\nvar easingPower4 = createEasing(function (x) {\n    var xx = x * x;\n    return xx * xx;\n});\nvar EXP_WEIGHT = 6;\nvar EXP_MAX = Math.exp(EXP_WEIGHT) - 1;\nfunction expFn(x) {\n    return (Math.exp(x * EXP_WEIGHT) - 1) / EXP_MAX;\n}\nvar easingExponential = createEasing(expFn);\nvar OVERSHOOT = 1.70158;\nvar easingBack = createEasing(function (x) { return x * x * ((OVERSHOOT + 1) * x - OVERSHOOT); });\nvar PARAM1 = 7.5625;\nvar PARAM2 = 2.75;\nfunction easeOutFn(x) {\n    var z = x;\n    if (z < 1 / PARAM2) {\n        return (PARAM1 * z * z);\n    }\n    else if (z < 2 / PARAM2) {\n        return (PARAM1 * (z -= 1.5 / PARAM2) * z + 0.75);\n    }\n    else if (z < 2.5 / PARAM2) {\n        return (PARAM1 * (z -= 2.25 / PARAM2) * z + 0.9375);\n    }\n    else {\n        return (PARAM1 * (z -= 2.625 / PARAM2) * z + 0.984375);\n    }\n}\nvar easingBounce = createEasing(function (x) { return 1 - easeOutFn(1 - x); });\nvar easingCirc = createEasing(function (x) { return -(Math.sqrt(1 - x * x) - 1); });\nvar PERIOD = 0.3;\nvar OVERSHOOT_ELASTIC = PERIOD / 4;\nvar AMPLITUDE = 1;\nfunction elasticIn(x) {\n    var z = x;\n    if (z <= 0) {\n        return 0;\n    }\n    else if (z >= 1) {\n        return 1;\n    }\n    else {\n        z -= 1;\n        return -(AMPLITUDE * Math.pow(2, 10 * z))\n            * Math.sin((z - OVERSHOOT_ELASTIC) * (2 * Math.PI) / PERIOD);\n    }\n}\nvar easingElastic = createEasing(elasticIn);\nvar HALF_PI = Math.PI * 0.5;\nvar easingSine = createEasing(function (x) { return 1 - Math.cos(x * HALF_PI); });\nvar DEFAULT_INTERVAL = 15;\n/**\n * Creates a stream of numbers emitted in a quick burst, following a numeric\n * function like sine or elastic or quadratic. tween() is meant for creating\n * streams for animations.\n *\n * Example:\n *\n * ```js\n * import tween from 'xstream/extra/tween'\n *\n * const stream = tween({\n *   from: 20,\n *   to: 100,\n *   ease: tween.exponential.easeIn,\n *   duration: 1000, // milliseconds\n * })\n *\n * stream.addListener({\n *   next: (x) => console.log(x),\n *   error: (err) => console.error(err),\n *   complete: () => console.log('concat completed'),\n * })\n * ```\n *\n * The stream would behave like the plot below:\n *\n * ```text\n * 100                  #\n * |\n * |\n * |\n * |\n * 80                  #\n * |\n * |\n * |\n * |                  #\n * 60\n * |\n * |                 #\n * |\n * |                #\n * 40\n * |               #\n * |              #\n * |            ##\n * |         ###\n * 20########\n * +---------------------> time\n * ```\n *\n * Provide a configuration object with **from**, **to**, **duration**, **ease**,\n * **interval** (optional), and this factory function will return a stream of\n * numbers following that pattern. The first number emitted will be `from`, and\n * the last number will be `to`. The numbers in between follow the easing\n * function you specify in `ease`, and the stream emission will last in total\n * `duration` milliseconds.\n *\n * The easing functions are attached to `tween` too, such as\n * `tween.linear.ease`, `tween.power2.easeIn`, `tween.exponential.easeOut`, etc.\n * Here is a list of all the available easing options:\n *\n * - `tween.linear` with ease\n * - `tween.power2` with easeIn, easeOut, easeInOut\n * - `tween.power3` with easeIn, easeOut, easeInOut\n * - `tween.power4` with easeIn, easeOut, easeInOut\n * - `tween.exponential` with easeIn, easeOut, easeInOut\n * - `tween.back` with easeIn, easeOut, easeInOut\n * - `tween.bounce` with easeIn, easeOut, easeInOut\n * - `tween.circular` with easeIn, easeOut, easeInOut\n * - `tween.elastic` with easeIn, easeOut, easeInOut\n * - `tween.sine` with easeIn, easeOut, easeInOut\n *\n * @factory true\n * @param {TweenConfig} config An object with properties `from: number`,\n * `to: number`, `duration: number`, `ease: function` (optional, defaults to\n * linear), `interval: number` (optional, defaults to 15).\n * @return {Stream}\n */\nfunction tween(_a) {\n    var from = _a.from, to = _a.to, duration = _a.duration, _b = _a.ease, ease = _b === void 0 ? tweenFactory.linear.ease : _b, _c = _a.interval, interval = _c === void 0 ? DEFAULT_INTERVAL : _c;\n    var totalTicks = Math.round(duration / interval);\n    return index_1.Stream.periodic(interval)\n        .take(totalTicks)\n        .map(function (tick) { return ease(tick / totalTicks, from, to); })\n        .compose(function (s) { return concat_1.default(s, index_1.Stream.of(to)); });\n}\nvar tweenFactory = tween;\ntweenFactory.linear = { ease: interpolate };\ntweenFactory.power2 = easingPower2;\ntweenFactory.power3 = easingPower3;\ntweenFactory.power4 = easingPower4;\ntweenFactory.exponential = easingExponential;\ntweenFactory.back = easingBack;\ntweenFactory.bounce = easingBounce;\ntweenFactory.circular = easingCirc;\ntweenFactory.elastic = easingElastic;\ntweenFactory.sine = easingSine;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = tweenFactory;\n//# sourceMappingURL=tween.js.map","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/combine.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs')\nvar kefir = require('kefir');\nvar bacon = require('baconjs');\nvar lodash = require('lodash');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// Create a stream from an Array of n integers\n// filter out odds, map remaining evens by adding 1, then reduce by summing\nvar n = runners.getIntArg(500000);\nvar a = new Array(n);\nfor(var i = 0; i< a.length; ++i) {\n  a[i] = i;\n}\n\nvar suite = Benchmark.Suite('combine(add3) -> filter ' + n + ' x 3 integers');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nfunction add3(a, b, c) {\n  return a + b + c;\n}\nfunction add3Arr(arr) {\n  return arr[0] + arr[1] + arr[2];\n}\n\nvar xs1 = xs.fromArray(a);\nvar xs2 = xs.fromArray(a);\nvar xs3 = xs.fromArray(a);\n\nvar m1 = most.from(a);\nvar m2 = most.from(a);\nvar m3 = most.from(a);\n\nvar rx1 = rxjs.Observable.from(a);\nvar rx2 = rxjs.Observable.from(a);\nvar rx3 = rxjs.Observable.from(a);\n\nsuite\n  .add('xstream', function(deferred) {\n    runners.runXStream(deferred,\n      xs.combine(xs1, xs2, xs3).map(add3Arr).filter(even));\n  }, options)\n  .add('most', function(deferred) {\n    runners.runMost(deferred,\n      most.combineArray(add3, [m1, m2, m3]).filter(even).drain());\n  }, options)\n  .add('rx 5', function(deferred) {\n    runners.runRx5(deferred,\n      rxjs.Observable.combineLatest(rx1, rx2, rx3, add3).filter(even));\n  }, options)\n\nrunners.runSuite(suite);\n\nfunction add1(x) {\n  return x + 1;\n}\n\nfunction even(x) {\n  return x % 2 === 0;\n}\n\nfunction sum(x, y) {\n  return x + y;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/dataflow.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs')\nvar bacon = require('baconjs');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// Create a stream from an Array of n integers\n// filter out odds, map remaining evens by adding 1, then reduce by summing\nvar seed = 100;\nvar x = seed;\nvar goingUp = true;\nvar n = runners.getIntArg(1000000);\nvar a = new Array(n);\nfor(var i = 0; i < a.length; ++i) {\n  if (x > Number('1e+100')) {\n    goingUp = false;\n  }\n  if (x < 100) {\n    goingUp = true;\n  }\n  if (goingUp) {\n    x *= 7;\n  } else {\n    x /= 7;\n  }\n  a[i] = Math.sin(x);\n}\n\nvar suite = Benchmark.Suite('dataflow for ' + n + ' source events');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nsuite\n  .add('xstream', function (deferred) {\n    var source = xs.fromArray(a);\n    var inc = source.filter(isPositive).mapTo(+1);\n    var dec = source.filter(isNegative).mapTo(-1);\n    var count = xs.merge(inc, dec).fold(addXY, 0);\n    var label = xs.of('initial', 'Count is ');\n    var view = xs.combine(label, count).map(renderWithArray);\n    runners.runXStream(deferred, view);\n  }, options)\n  .add('most', function (deferred) {\n    var source = most.from(a);\n    var inc = source.filter(isPositive).map(returnPlus1);\n    var dec = source.filter(isNegative).map(returnMinus1);\n    var count = most.merge(inc, dec).scan(addXY, 0);\n    var label = most.from(['initial', 'Count is ']);\n    var view = most.combine(renderWithArgs, label, count);\n    runners.runMost(deferred, view.drain());\n  }, options)\n  .add('rx 5', function (deferred) {\n    var source = rxjs.Observable.from(a);\n    var inc = source.filter(isPositive).map(returnPlus1);\n    var dec = source.filter(isNegative).map(returnMinus1);\n    var count = rxjs.Observable.merge(inc, dec).scan(addXY, 0);\n    var label = rxjs.Observable.of('initial', 'Count is ');\n    var view = rxjs.Observable.combineLatest(label, count, renderWithArgs);\n    runners.runRx5(deferred, view);\n  }, options)\n  .add('rx 4', function (deferred) {\n    var source = rx.Observable.from(a);\n    var inc = source.filter(isPositive).map(returnPlus1);\n    var dec = source.filter(isNegative).map(returnMinus1);\n    var count = rx.Observable.merge(inc, dec).scan(addXY, 0);\n    var label = rx.Observable.of('initial', 'Count is ');\n    var view = rx.Observable.combineLatest(label, count, renderWithArgs);\n    runners.runRx(deferred, view);\n  }, options)\n  .add('bacon', function (deferred) {\n    var source = bacon.fromArray(a);\n    var inc = source.filter(isPositive).map(returnPlus1);\n    var dec = source.filter(isNegative).map(returnMinus1);\n    var count = inc.merge(dec).scan(0, addXY);\n    var label = bacon.fromArray(['initial', 'Count is ']);\n    var view = bacon.combineWith(renderWithArgs, label, count);\n    runners.runBacon(deferred, view);\n  }, options)\n\nrunners.runSuite(suite);\n\nfunction isNegative(x) {\n  return x < 0;\n}\n\nfunction isPositive(x) {\n  return x > 0;\n}\n\nfunction addXY(x, y) {\n  return x + y;\n}\n\nfunction returnPlus1() {\n  return +1;\n}\n\nfunction returnMinus1() {\n  return -1;\n}\n\nfunction renderWithArray(labelAndCount) {\n  return {\n    label: labelAndCount[0],\n    count: labelAndCount[1],\n  };\n}\n\nfunction renderWithArgs(label, count) {\n  return {\n    label: label,\n    count: count,\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/filter-map-fusion.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs')\nvar kefir = require('kefir');\nvar bacon = require('baconjs');\nvar lodash = require('lodash');\nvar highland = require('highland');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// Create a stream from an Array of n integers\n// filter out odds, map remaining evens by adding 1, then reduce by summing\nvar n = runners.getIntArg(1000000);\nvar a = new Array(n);\nfor(var i = 0; i< a.length; ++i) {\n  a[i] = i;\n}\n\nvar suite = Benchmark.Suite('filter -> map -> fusion ' + n + ' integers');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nsuite\n  .add('xstream', function(deferred) {\n    runners.runXStream(deferred,\n      xs.fromArray(a).map(add1).filter(odd).map(add1).map(add1).filter(even).fold(sum, 0).last());\n  }, options)\n  .add('most', function(deferred) {\n    runners.runMost(deferred, most.from(a).map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(sum, 0));\n  }, options)\n  .add('rx 5', function(deferred) {\n    runners.runRx5(deferred,\n      rxjs.Observable.from(a).map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(sum, 0));\n  }, options)\n  .add('rx 4', function(deferred) {\n    runners.runRx(deferred, rx.Observable.fromArray(a).map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(sum, 0));\n  }, options)\n  .add('kefir', function(deferred) {\n    runners.runKefir(deferred, kefirFromArray(a).map(add1).filter(odd).map(add1).map(add1).filter(even).scan(sum, 0).last());\n  }, options)\n  .add('bacon', function(deferred) {\n    runners.runBacon(deferred, bacon.fromArray(a).map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(0, sum));\n  }, options)\n  .add('highland', function(deferred) {\n    runners.runHighland(deferred, highland(a).map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(0, sum));\n  }, options)\n  .add('lodash', function() {\n    return lodash(a).map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(sum, 0);\n  })\n  .add('Array', function() {\n    return a.map(add1).filter(odd).map(add1).map(add1).filter(even).reduce(sum, 0);\n  })\n\nrunners.runSuite(suite);\n\nfunction add1(x) {\n  return x + 1;\n}\n\nfunction even(x) {\n  return x % 2 === 0;\n}\n\nfunction odd(x) {\n  return x % 2 !== 0;\n}\n\nfunction sum(x, y) {\n  return x + y;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/filter-map-reduce.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs')\nvar kefir = require('kefir');\nvar bacon = require('baconjs');\nvar lodash = require('lodash');\nvar highland = require('highland');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// Create a stream from an Array of n integers\n// filter out odds, map remaining evens by adding 1, then reduce by summing\nvar n = runners.getIntArg(1000000);\nvar a = new Array(n);\nfor(var i = 0; i< a.length; ++i) {\n  a[i] = i;\n}\n\nvar suite = Benchmark.Suite('filter -> map -> reduce ' + n + ' integers');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nsuite\n  .add('xstream', function(deferred) {\n    runners.runXStream(deferred,\n      xs.fromArray(a).filter(even).map(add1).fold(sum, 0).last());\n  }, options)\n  .add('most', function(deferred) {\n    runners.runMost(deferred, most.from(a).filter(even).map(add1).reduce(sum, 0));\n  }, options)\n  .add('rx 5', function(deferred) {\n    runners.runRx5(deferred,\n      rxjs.Observable.from(a).filter(even).map(add1).reduce(sum, 0));\n  }, options)\n  .add('rx 4', function(deferred) {\n    runners.runRx(deferred, rx.Observable.fromArray(a).filter(even).map(add1).reduce(sum, 0));\n  }, options)\n  .add('kefir', function(deferred) {\n    runners.runKefir(deferred, kefirFromArray(a).filter(even).map(add1).scan(sum, 0).last());\n  }, options)\n  .add('bacon', function(deferred) {\n    runners.runBacon(deferred, bacon.fromArray(a).filter(even).map(add1).reduce(0, sum));\n  }, options)\n  .add('highland', function(deferred) {\n    runners.runHighland(deferred, highland(a).filter(even).map(add1).reduce(0, sum));\n  }, options)\n  .add('lodash', function() {\n    return lodash(a).filter(even).map(add1).reduce(sum, 0);\n  })\n  .add('Array', function() {\n    return a.filter(even).map(add1).reduce(sum, 0);\n  })\n\nrunners.runSuite(suite);\n\nfunction add1(x) {\n  return x + 1;\n}\n\nfunction even(x) {\n  return x % 2 === 0;\n}\n\nfunction sum(x, y) {\n  return x + y;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/flatten.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs')\nvar kefir = require('kefir');\nvar bacon = require('baconjs');\nvar lodash = require('lodash');\nvar highland = require('highland');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// flatMapping n streams, each containing m items.\n// Results in a single stream that merges in n x m items\n// In Array parlance: Take an Array containing n Arrays, each of length m,\n// and flatten it to an Array of length n x m.\nvar mn = runners.getIntArg2(1000, 1000);\nvar a = build(mn[0], mn[1]);\n\nfunction build(m, n) {\n  var a = new Array(n);\n  for(var i = 0; i< a.length; ++i) {\n    a[i] = buildArray(i*1000, m);\n  }\n  return a;\n}\n\nfunction buildArray(base, n) {\n  var a = new Array(n);\n  for(var i = 0; i< a.length; ++i) {\n    a[i] = base + i;\n  }\n  return a;\n}\n\nvar suite = Benchmark.Suite('switchMap ' + mn[0] + ' x ' + mn[1] + ' streams');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nsuite\n  .add('xstream', function(deferred) {\n    runners.runXStream(deferred,\n      xs.fromArray(a).map(xs.fromArray).flatten().fold(sum, 0).last());\n  }, options)\n  .add('most', function(deferred) {\n    runners.runMost(deferred, most.from(a).map(most.from).switch().reduce(sum, 0));\n  }, options)\n  .add('rx 5', function(deferred) {\n    runners.runRx5(deferred,\n      rxjs.Observable.from(a).switchMap(\n        function(x) {return rxjs.Observable.from(x)}).reduce(sum, 0))\n  }, options)\n  .add('rx 4', function(deferred) {\n    runners.runRx(deferred,\n      rx.Observable.fromArray(a).flatMapLatest(\n        function(x) {return rx.Observable.fromArray(x)}).reduce(sum, 0));\n  }, options)\n  .add('kefir', function(deferred) {\n    runners.runKefir(deferred, kefirFromArray(a).flatMapLatest(kefirFromArray).scan(sum, 0).last());\n  }, options)\n  .add('bacon', function(deferred) {\n    runners.runBacon(deferred, bacon.fromArray(a).flatMapLatest(bacon.fromArray).reduce(0, sum));\n  }, options)\n\nrunners.runSuite(suite);\n\nfunction arrayFlatMap(f, a) {\n  return a.reduce(function(a, x) {\n    return a.concat(f(x));\n  }, []);\n}\n\nfunction lodashFlatMap(f, a) {\n  return lodash(a).map(f).flatten();\n}\n\nfunction sum(x, y) {\n  return x + y;\n}\n\nfunction even(x) {\n  return x % 2 === 0;\n}\n\nfunction identity(x) {\n  return x;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/fold.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs');\nvar kefir = require('kefir');\nvar bacon = require('baconjs');\nvar lodash = require('lodash');\nvar highland = require('highland');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// Create a stream from an Array of n integers\n// filter out odds, map remaining evens by adding 1, then reduce by summing\nvar n = runners.getIntArg(1000000);\nvar a = new Array(n);\nfor(var i = 0; i< a.length; ++i) {\n  a[i] = i;\n}\n\nvar suite = Benchmark.Suite('scan -> reduce ' + n + ' integers');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nsuite\n  .add('xstream', function(deferred) {\n    runners.runXStream(deferred, xs.fromArray(a).fold(sum, 0).fold(passthrough, 0).last());\n  }, options)\n  .add('most', function(deferred) {\n    runners.runMost(deferred, most.from(a).scan(sum, 0).reduce(passthrough, 0));\n  }, options)\n  .add('rx 5', function(deferred) {\n    runners.runRx5(deferred, rxjs.Observable.from(a).scan(sum, 0).reduce(passthrough, 0));\n  }, options)\n  .add('rx 4', function(deferred) {\n    runners.runRx(deferred, rx.Observable.fromArray(a).scan(sum, 0).reduce(passthrough, 0));\n  }, options)\n  .add('kefir', function(deferred) {\n    runners.runKefir(deferred, kefirFromArray(a).scan(sum, 0).scan(passthrough, 0).last());\n  }, options)\n  .add('bacon', function(deferred) {\n    runners.runBacon(deferred, bacon.fromArray(a).scan(0, sum).reduce(0, passthrough));\n  }, options)\n  .add('highland', function(deferred) {\n    runners.runHighland(deferred, highland(a).scan(0, sum).reduce(0, passthrough));\n  }, options)\n  .add('lodash', function() {\n    return lodashScan(sum, 0, a).reduce(passthrough, 0);\n  })\n  .add('Array', function() {\n    return arrayScan(sum, 0, a).reduce(passthrough, 0);\n  })\n\nrunners.runSuite(suite);\n\nfunction arrayScan(f, initial, a) {\n  var result = initial;\n  return a.map(function(x) {\n    return result = f(result, x);\n  });\n}\n\nfunction lodashScan(f, initial, a) {\n  var result = initial;\n  return lodash(a).map(function(x) {\n    return result = f(result, x);\n  });\n}\n\nfunction sum(x, y) {\n  return x + y;\n}\n\nfunction passthrough(z, x) {\n  return x;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/merge.js":"var Benchmark = require('benchmark');\nvar xs = require('../index').default;\nvar most = require('most');\nvar rx = require('rx');\nvar rxjs = require('@reactivex/rxjs');\nvar kefir = require('kefir');\nvar bacon = require('baconjs');\nvar lodash = require('lodash');\nvar highland = require('highland');\n\nvar runners = require('./runners');\nvar kefirFromArray = runners.kefirFromArray;\n\n// flatMapping n streams, each containing m items.\n// Results in a single stream that merges in n x m items\n// In Array parlance: Take an Array containing n Arrays, each of length m,\n// and flatten it to an Array of length n x m.\nvar mn = runners.getIntArg2(100000, 10);\nvar a = build(mn[0], mn[1]);\n\nfunction build(m, n) {\n  var a = new Array(n);\n  for(var i = 0; i< a.length; ++i) {\n    a[i] = buildArray(i*1000, m);\n  }\n  return a;\n}\n\nfunction buildArray(base, n) {\n  var a = new Array(n);\n  for(var i = 0; i< a.length; ++i) {\n    a[i] = base + i;\n  }\n  return a;\n}\n\nvar suite = Benchmark.Suite('merge ' + mn[0] + ' x ' + mn[1] + ' streams');\nvar options = {\n  defer: true,\n  onError: function(e) {\n    e.currentTarget.failure = e.error;\n  }\n};\n\nsuite\n  .add('xstream', function(deferred) {\n    var streams = a.map(xs.fromArray);\n    runners.runXStream(deferred,\n      xs.merge.apply(void 0, streams).fold(sum, 0).last());\n  }, options)\n  .add('most', function(deferred) {\n    var streams = a.map(most.from);\n    runners.runMost(deferred, most.mergeArray(streams).reduce(sum, 0));\n  }, options)\n  .add('rx 5', function(deferred) {\n    var streams = a.map(function(x) {return rxjs.Observable.from(x)});\n    runners.runRx5(deferred,\n      rxjs.Observable.merge.apply(rxjs.Observable, streams).reduce(sum, 0))\n  }, options)\n  .add('rx 4', function(deferred) {\n    var streams = a.map(rx.Observable.fromArray);\n    runners.runRx(deferred, rx.Observable.merge.apply(void 0, streams).reduce(sum, 0));\n  }, options)\n  .add('kefir', function(deferred) {\n    var streams = a.map(kefirFromArray);\n    runners.runKefir(deferred, kefir.merge(streams).scan(sum, 0).last());\n  }, options)\n  .add('bacon', function(deferred) {\n    var streams = a.map(bacon.fromArray);\n    runners.runBacon(deferred, bacon.mergeAll(streams).reduce(0, sum));\n  }, options)\n  .add('lodash', function() {\n    // \"Merge\" synchronous arrays by concatenation\n    return lodash(a).flatten().reduce(sum, 0);\n  })\n  .add('Array', function() {\n    // \"Merge\" synchronous arrays by concatenation\n    return Array.prototype.concat.apply([], a).reduce(sum, 0);\n  })\n\nrunners.runSuite(suite);\n\nfunction sum(x, y) {\n  return x + y;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/perf/runners.js":"var kefir = require('kefir');\nkefir.DEPRECATION_WARNINGS = false;\n\nexports.runSuite       = runSuite;\n\nexports.runMost        = runMost;\nexports.runRx          = runRx;\nexports.runRx5         = runRx5;\nexports.runXStream     = runXStream;\nexports.runKefir       = runKefir;\nexports.kefirFromArray = kefirFromArray;\nexports.runBacon       = runBacon;\nexports.runHighland    = runHighland;\n\nexports.getIntArg      = getIntArg;\nexports.getIntArg2     = getIntArg2;\nexports.logResults     = logResults;\n\nfunction noop() {}\n\nfunction _getIntArg(defaultValue, index) {\n  var n = parseInt(process.argv[index]);\n  return isNaN(n) ? defaultValue : n;\n}\n\nfunction getIntArg(defaultValue) {\n  return _getIntArg(defaultValue, process.argv.length - 1);\n}\n\nfunction getIntArg2(default1, default2) {\n  var m = _getIntArg(default1, process.argv.length - 2);\n  var n = _getIntArg(default2, process.argv.length - 1);\n  return [m, n];\n}\n\nfunction logResults(e) {\n  var t = e.target;\n\n  if(t.failure) {\n    console.error(padl(10, t.name) + 'FAILED: ' + e.target.failure);\n  } else {\n    var result = padl(10, t.name)\n      + padr(13, t.hz.toFixed(2) + ' op/s')\n      + ' \\xb1' + padr(7, t.stats.rme.toFixed(2) + '%')\n      + padr(15, ' (' + t.stats.sample.length + ' samples)');\n\n    console.log(result);\n  }\n}\n\nfunction logStart() {\n  console.log(this.name);\n  console.log('-----------------------------------------------');\n}\n\nfunction logComplete() {\n  console.log('-----------------------------------------------');\n}\n\nfunction runSuite(suite) {\n  return suite\n    .on('start', logStart)\n    .on('cycle', logResults)\n    .on('complete', logComplete)\n    .run();\n}\n\nfunction runMost(deferred, mostPromise) {\n  mostPromise.then(function() {\n    deferred.resolve();\n  }, function(e) {\n    deferred.benchmark.emit({ type: 'error', error: e });\n    deferred.resolve(e);\n  });\n}\n\nfunction runRx(deferred, rxStream) {\n  rxStream.subscribe({\n    onNext: noop,\n    onCompleted: function() {\n      deferred.resolve();\n    },\n    onError: function(e) {\n      deferred.benchmark.emit({ type: 'error', error: e });\n      deferred.resolve(e);\n    }\n  });\n}\n\nfunction runRx5(deferred, rxStream) {\n  rxStream.subscribe({\n    next: noop,\n    complete: function() {\n      deferred.resolve();\n    },\n    error: function(e) {\n      deferred.benchmark.emit({ type: 'error', error: e });\n      deferred.resolve(e);\n    }\n  });\n}\n\nfunction runXStream(deferred, xstream) {\n  xstream.addListener({\n    next: noop,\n    complete: function() {\n      deferred.resolve();\n    },\n    error: function(e) {\n      deferred.benchmark.emit({ type: 'error', error: e });\n      deferred.resolve(e);\n    }\n  });\n}\n\nfunction runKefir(deferred, kefirStream) {\n  kefirStream.onValue(noop);\n  kefirStream.onEnd(function() {\n    deferred.resolve();\n  });\n}\n\nfunction kefirFromArray(array) {\n  return kefir.stream(function(emitter) {\n    for(var i=0; i<array.length; ++i) {\n      emitter.emit(array[i]);\n    }\n    emitter.end();\n  });\n}\n\nfunction runBacon(deferred, baconStream) {\n  try {\n    baconStream.onValue(noop);\n    baconStream.onEnd(function() {\n      deferred.resolve();\n    });\n    baconStream.onError(function(e) {\n      deferred.benchmark.emit({ type: 'error', error: e });\n      deferred.resolve(e);\n    });\n  } catch(e) {\n    deferred.benchmark.emit({ type: 'error', error: e });\n    deferred.resolve(e);\n  }\n}\n\n// Using pull() seems to give the fastest results for highland,\n// but will only work for test runs that reduce a stream to a\n// single value.\nfunction runHighland(deferred, highlandStream) {\n  highlandStream.pull(function(err, z) {\n    if(err) {\n      deferred.reject(err);\n      return;\n    }\n\n    deferred.resolve(z);\n  });\n}\n\nfunction padl(n, s) {\n  while(s.length < n) {\n    s += ' ';\n  }\n  return s;\n}\n\nfunction padr(n, s) {\n  while (s.length < n) {\n    s = ' ' + s;\n  }\n  return s;\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/check-release.js":"#!/usr/bin/env node\n\n/** This script checks whether xstream should be released with\n * a new version according to ComVer https://github.com/staltz/comver.\n * It has two modes: REPORT and ORACLE.\n *\n * It runs in REPORT mode if no additional command line argument was given.\n * For instance, `node check-release.js`. It will display a human readable\n * report about a new release possibility.\n *\n * It runs in ORACLE mode if `--oracle` or `-o` was given as option, e.g.\n * `node check-release.js --oracle`,\n * it will exit with a status code answering whether the\n * package should be released with a new version.\n * 0 means no new release is necessary\n * 2 means it should have a new minor version _.x release\n * 3 means it should have a new major version x._ release\n */\n\nvar conventionalChangelog = require('conventional-changelog');\nvar fs = require('fs');\n\nvar status = {increment: 0, commits: []};\n\nfunction incrementName(code) {\n  if (code === 1) {\n    return 'patch';\n  } else if (code === 2) {\n    return 'minor';\n  } else if (code === 3) {\n    return 'major';\n  } else {\n    return '';\n  }\n}\n\nfunction isCommitBreakingChange(commit) {\n  return (typeof commit.footer === 'string'\n    && commit.footer.indexOf('BREAKING CHANGE') !== -1);\n}\n\nfunction showReportHeaderPositive() {\n  console.log(\n    'RELEASES TO DO\\n\\n' +\n    'We checked all recent commits, and discovered that according\\n' +\n    'to ComVer (https://github.com/staltz/comver) you should\\n' +\n    'release a new version of xstream.\\n');\n}\n\nfunction showReportHeaderNegative() {\n  console.log(\n    'Nothing to release.\\n\\n' +\n    'We checked all recent commits, and discovered that you do\\n' +\n    'not need to release a new version, according to ComVer.\\n')\n}\n\nfunction showReport(status) {\n  if (status.increment > 0) {\n    showReportHeaderPositive();\n\n    console.log('xstream needs a new ' +\n      incrementName(status.increment).toUpperCase() +\n      ' version released because:');\n    status.commits.forEach(function (commit) {\n      console.log('  . ' + commit.header);\n      if (isCommitBreakingChange(commit)) {\n        console.log('    BREAKING CHANGE');\n      }\n    });\n    console.log('');\n  } else {\n    showReportHeaderNegative();\n  }\n}\n\nconventionalChangelog({\n  preset: 'angular',\n  append: true,\n  transform: function (commit, cb) {\n    var toPush = null;\n    if (commit.type === 'fix' || commit.type === 'feat' || commit.type === 'perf') {\n      status.increment = Math.max(status.increment, 2);\n      toPush = commit;\n    }\n    if (isCommitBreakingChange(commit)) {\n      status.increment = Math.max(status.increment, 3);\n      toPush = commit;\n    }\n    if (toPush) {\n      status.commits.push(commit);\n    }\n    if (commit.header === 'chore(package): release new version') {\n      status.increment = 0;\n      status.commits = [];\n    }\n    cb();\n  },\n}, {}, { reverse: true })\n  .on('end', function () {\n    if (process.argv[2] === '--oracle' || process.argv[2] === '-o') {\n      return process.exit(status.increment);\n    } else {\n      showReport(status);\n    }\n  }).resume();","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/make-extras.js":"'use strict';\nvar fs = require('fs');\nvar generateDocs = require('./generate-docs');\n\nvar allExtraJSFiles = fs.readdirSync('./extra/') // is an array\n  .map(filename => './extra/' + filename)\n  .filter(filename => filename.match(/\\.js$/));\n\ngenerateDocs({\n  src: allExtraJSFiles,\n  output: './markdown/generated-extras.md',\n  template: './tools/template-extras.md.ejs'\n});\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/generate-docs.js":"'use strict';\nvar markdox = require('markdox');\n\nmodule.exports = function generateDocs(options) {\n  markdox.process(\n    options.src,\n    {output: options.output, template: options.template},\n    function generationCallback(err/*, output */) {\n      if (err) {\n        console.error(err);\n      } else {\n        console.log('File `' + options.output + '` generated with success');\n      }\n    }\n  );\n}\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/make-factories.js":"'use strict';\nvar generateDocs = require('./generate-docs');\n\ngenerateDocs({\n  src: './index.js',\n  output: './markdown/generated-factories.md',\n  template: './tools/template-factories.md.ejs'\n});\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/make-methods.js":"'use strict';\nvar generateDocs = require('./generate-docs');\n\ngenerateDocs({\n  src: './index.js',\n  output: './markdown/generated-methods.md',\n  template: './tools/template-methods.md.ejs'\n});\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/make-toc.js":"'use strict';\nvar generateDocs = require('./generate-docs');\n\ngenerateDocs({\n  src: './index.js',\n  output: './markdown/generated-toc.md',\n  template: './tools/template-toc.md.ejs'\n});\n","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/minify.js":"var compiler = require('google-closure-compiler-js').compile;\nvar fs = require('fs');\nvar source = fs.readFileSync('dist/xstream.js', 'utf8');\n\nvar compilerFlags = {\n  jsCode: [{src: source}],\n  languageIn: 'ES5',\n  createSourceMap: true,\n  // compilationLevel: 'ADVANCED',\n};\n\nvar output = compiler(compilerFlags);\nfs.writeFileSync('dist/xstream.min.js', output.compiledCode, 'utf8');\nfs.writeFileSync('dist/xstream.min.js.map', output.sourceMap, 'utf8');","/home/travis/build/npmtest/node-npmtest-xstream/node_modules/xstream/tools/strip-comments.js":"var stripComments = require('strip-comments')\n\nprocess.stdin.setEncoding('utf8');\n\nvar data = '';\n\nprocess.stdin.on('readable', () => {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    data = data + chunk;\n  }\n});\n\nprocess.stdin.on('end', () => {\n  process.stdout.write(stripComments(data));\n});\n"}